{"meta":{"title":"privatearea","subtitle":"会当凌绝顶，一览众山小","description":null,"author":"bingone","url":"http://mijiku.com.cn/blog","root":"/blog/"},"pages":[{"title":"About","date":"2019-04-24T02:09:54.000Z","updated":"2019-04-28T08:38:28.676Z","comments":true,"path":"about/index.html","permalink":"http://mijiku.com.cn/blog/about/index.html","excerpt":"","text":"QQ:277835572weixin:kof98765mail:277835572@qq.com"},{"title":"tags","date":"2019-04-24T02:09:40.000Z","updated":"2019-04-24T02:11:57.178Z","comments":true,"path":"tags/index.html","permalink":"http://mijiku.com.cn/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"IEC61850建模说明","slug":"IEC61850建模说明","date":"2021-01-14T03:12:36.209Z","updated":"2021-01-14T08:33:36.370Z","comments":true,"path":"2021/01/14/IEC61850建模说明/","link":"","permalink":"http://mijiku.com.cn/blog/2021/01/14/IEC61850建模说明/","excerpt":"","text":"1.概述IEC61850的数据建模，主要是看IEC1850标准的第7部分，变电站和馈线高备的基本通信结构(7-1,7-2,7-3,7-4)数据建模，实际上就是将设备的点表按照IEC61850标准的规则编写的一份点表文件，该点表以XML的格式描述，后缀名为.icd，另一个名字叫智能电子设备能力描述文件 1.1 IEC61850服务以下是61850的服务与传统功能的对比列表： 服务与传统变电站功能 IEC61850服务 传统功能 报告服务 遥信、遥测 控制服务 遥控、遥调 定值服务 定值召唤、修改、切换 日志服务 事件服务 取代服务 人工置数 对时服务 GPS对时 文件传输服务 文件传输 采样值传输服务 模拟量采样传输 GOOSE服务 装置间快速信号传输 2.数据建模介绍在建模前，应熟知61850数据模型所含的内容及其作用。详细请看61850标准的第6部分，第7-2部分。每个模型都具有四个对象，依次为SERVER 服务器LOGICAL-DEVICE 简称LD，逻辑设备LOGICAL-NODE 简称LN，逻辑结点DATA 数据，逻辑结点中的数据点 每个对象都有各自的名称和对象路径名,假设有一个61850服务器，SERVER为acSystem,LOGICAL-DEVICE为ac,LOGICAL-NODE为alarm,有若干数据点名为alarm1,alarm2,alarm3，外部访问服务器的一个结点引用为acSystem.ac.alarm.alarm1我们通常要改的就是LN部分 3.建模说明一般来说，不需要从零开始配置一份数据模型icd文件，直接在已有的文件修改即可， 3.1 icd文件介绍以下是一个最简单的icd文件1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;SCL version=&quot;2007&quot; revision=&quot;B&quot; xmlns=&quot;http://www.iec.ch/61850/2003/SCL&quot; xmlns:xsl=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.iec.ch/61850/2003/SCL SCL.xsd&quot;&gt;&lt;Header id=&quot;&quot; version=&quot;&quot; revision=&quot;&quot; toolID=&quot;OMICRON IEDScout&quot; nameStructure=&quot;IEDName&quot; /&gt;&lt;IED name=&quot;EAST01&quot;&gt;&lt;Services&gt; &lt;AccessPoint name=&quot;P1&quot;&gt; &lt;Server&gt; &lt;Authentication none=&quot;true&quot;/&gt; &lt;LDevice inst=&quot;DEV1&quot;&gt; &lt;LN0 lnType=&quot;EAST01DEV1.LLN0&quot; lnClass=&quot;LLN0&quot; inst=&quot;&quot;&gt; &lt;DOI name=&quot;Mod&quot;&gt; &lt;DAI name=&quot;ctlModel&quot; &gt; &lt;Val&gt;status-only&lt;/Val&gt; &lt;/DAI&gt; &lt;/DOI&gt; &lt;/LN0&gt; &lt;/LDevice&gt; &lt;/Server&gt; &lt;/AccessPoint&gt;&lt;/Services&gt;&lt;/IED&gt;&lt;DataTypeTemplates&gt; &lt;LNodeType id=&quot;EAST01DEV1.LLN0&quot; lnClass=&quot;LLN0&quot;&gt; &lt;DO name=&quot;Mod&quot; type=&quot;EAST01DEV1.LLN0.Mod&quot;/&gt; &lt;DO name=&quot;ctlModel&quot; type=&quot;EAST01DEV1.LLN0.ctlModel&quot;&gt; &lt;/LNodeType&gt; &lt;DOType id=&quot;EAST01DEV1.LLN0.Mod&quot; cdc=&quot;INC&quot;&gt; &lt;DA name=&quot;stVal&quot; fc=&quot;ST&quot; bType=&quot;Enum&quot; type=&quot;Mod&quot;&gt; &lt;/DOType&gt; &lt;EnumType id=&quot;Mod&quot;&gt; &lt;EnumVal ord=&quot;1&quot;&gt;on&lt;/EnumVal&gt; &lt;EnumVal ord=&quot;2&quot;&gt;blocked&lt;/EnumVal&gt; &lt;EnumVal ord=&quot;3&quot;&gt;test&lt;/EnumVal&gt; &lt;EnumVal ord=&quot;4&quot;&gt;test/blocked&lt;/EnumVal&gt; &lt;EnumVal ord=&quot;5&quot;&gt;off&lt;/EnumVal&gt; &lt;/EnumType&gt; &lt;EnumType id=&quot;ctlModel&quot;&gt; &lt;EnumVal ord=&quot;0&quot;&gt;status-only&lt;/EnumVal&gt; &lt;EnumVal ord=&quot;1&quot;&gt;direct-with-normal-security&lt;/EnumVal&gt; &lt;EnumVal ord=&quot;2&quot;&gt;sbo-with-normal-security&lt;/EnumVal&gt; &lt;EnumVal ord=&quot;3&quot;&gt;direct-with-enhanced-security&lt;/EnumVal&gt; &lt;EnumVal ord=&quot;4&quot;&gt;sbo-with-enhanced-secrity&lt;/EnumVal&gt; &lt;/EnumType&gt;&lt;/DataTypeTemplates&gt;&lt;/SCL&gt; 从内容可以看出，包含两大块，IED和DataTypeTemplates,DataTypeTemplates为数据类型的模板，定义该设备拥有什么数据变量，变量的类型，单位等信息，IED为设备的对象实例，定义了数据的初始值，系数，单位，寄存器地址等信息 以上文件在LNodeType字段定义了一个数据stVal,类型是EAST01DEV1.LLN0.Mod,在DOType字段中有该类型的具体定义，其中cdc(公用数据类)为INC,即可控的整数状态，而INC又定义了它必选的和可选的属懂（IEC6850标准的7-3部分的7.5.4章节有说明） 3.2 InClass 逻辑节点类 表1 逻辑节点组表 逻辑节点组指示符 节点标识 A 自动控制 C 监控 G 通用功能引用 I 接口和存档 L 系统逻辑节点 M 计量和测量 P 保护功能 R 保护相关功能 S 传感器，监视 T 仪用互感器 X 开关设备 Y 电力变压器和相关功能 Z 其它(电力系统)设备 一般我们接触到的类有:LPHD(物理装置信息，IEC61850-7-4部分的5.3.2章节)LLN0(逻辑节点零，IEC61850-7-4部分的5.3.4章节)GGIO(通用过程I/O，IEC61850-7-44部分的5.7.2章节)MMXN(测量，IEC61850-7-4部分的5.10.7章节) 3.3 cdc公用数据类一般可以根据遥信，遥控，遥测，遥调四个功能来选择需要的cdc遥信=SPS(单点状态信息,IEC61850-7-3部分的7.3.2章节)遥控=SPC(可控的单点,IEC61850-7-3部分的7.5.2章节)遥测=MV(测量值，IEC61850-7-3部分的7.4.2章节)遥调=APC(可控模拟设点信息,IEC61850-7-3部分的7.6.2章节)其中，遥测和遥调的值可以是浮点或者整型，若选择整型，则应该增加数据属性sVC,即增加系数和偏移量以下是添加浮点型的示例123456&lt;DOType id=&quot;EAST01DEV1.MMXN1.Mea1&quot; cdc=&quot;MV&quot;&gt; &lt;DA name=&quot;mag&quot; fc=&quot;MX&quot; bType=&quot;Struct&quot; type=&quot;EAST01DEV1.MMXN.Mea1.mag&quot;&gt;&lt;/DOType&gt;&lt;DAType id=&quot;EAST01DEV1.MMXN1.Mea1.mag&quot;&gt; &lt;BDA name=&quot;f&quot; bType=&quot;FLOAT32&quot;/&gt;&lt;/DAType&gt; 以下是添加整型的示例1234567&lt;DOType id=&quot;EAST01DEV1.MMXN1.Mea1&quot; cdc=&quot;MV&quot;&gt; &lt;DA name=&quot;sVC&quot; fc=&quot;MX&quot; bType=&quot;Struct&quot; type=&quot;ScaledValueConfig_1&quot;&gt;&lt;/DOType&gt;&lt;DAType id=&quot;ScaledValueConfig_1&quot;&gt; &lt;BDA name=&quot;scaleFactor&quot; bType=&quot;FLOAT32&quot;/&gt; &lt;BDA name=&quot;offset&quot; bType=&quot;FLOAT32&quot;/&gt;&lt;/DAType&gt; 3.4 配置数据对象配置数据对象需要在DataTypeTemplates的LNodeType字段中添加DO结点，DO有很多种类型，一般我们按遥信，遥控，遥测，遥测四种类型配置即可，DO有三个属性，分别为name,type,descname是固定的，一般字符串就行，尽量和要表达的属性命令匹配，容易维护type需要根据当前数据来定，按3.3的说明即可，详情可以看IEC61850-7-3部分的8章节desc为数据的描述fc为功能约束，常用的是ST(状态)，MX(测量),CO(控制),DC(描述),CF(配置)，具体可以查看IEC61850-7-3部分的附录B 3.5 配置数据对象实例配置对象实例就是将上一节所定的数据都初始化一遍，包括寄存器映射地址，变量名，单位，系数等，具体看第一节的示例 3.6 配置报告配置报告分为两个步骤，分别是配置数据集和配置报告控制块，而且都是在LN0节点中配置 我们可以将数据分为遥信，遥控，遥测，遥调四个数据集，分别上报，下面配置遥信量作为数据集的例子，格式如下 12345&lt;LN0 lnType=&quot;EASTDEV01DEV1.LLN0&quot; lnClass=&quot;LLN0&quot; inst=&quot;&quot;&gt; &lt;DataSet name=&quot;ds01Digit&quot;&gt; &lt;FCDA ldInst=&quot;DEV1&quot; prefix=&quot;&quot; lnClass=&quot;GGIO&quot; lnInst=&quot;1&quot; doName=&quot;Ind1&quot; fc=&quot;ST&quot;&gt; &lt;/DataSet&gt;&lt;/LN0&gt; 注意，控制集里面的数据对象一定是在DataTypeTemplates的LNodeType字段中找得到的 配置报告控制块用于指定所需报告的数据集，一般来说，有多少数据集就有多少个报告控制块，以下是是控制块的例子12345&lt;ReportControl name=&quot;urcbDigit1&quot; rptID=&quot;DEV1/LLN0$RP$urcbDigit1&quot; buffered=&quot;false&quot; bufTime=&quot;0&quot; datSet=&quot;ds01Digit&quot; intgPd=&quot;20000&quot; confRev=&quot;1&quot;&gt;&lt;trgOps dchg=&quot;true&quot; qchg=&quot;true&quot; dupd=&quot;false&quot; period=&quot;true&quot; gi=&quot;true&quot; /&gt;&lt;OptFileds seqNum=&quot;false&quot; timeStamp=&quot;true&quot; dataSet=&quot;true&quot; reasonCode=&quot;true&quot; dataRef=&quot;false&quot; entryID=&quot;false&quot; configRef=&quot;false&quot; /&gt;&lt;RtlEnabled max=&quot;4&quot; /&gt;&lt;/ReportControl&gt; 一般只要修改datset和RptEnabled的max值即可datset指定上送的数据集名称，max值指定最多有多少个客户端能接收该报告 4.生成和检验模型4.1 生成model.cfg文件使用iec61850库时，需要将icd文件转为其规定的cfg文件，转换工具在libiec61850库的tools/model_generator里，使用命令1java -jar genconfig.jar xxx.icd &gt;model.cfg 注意需要在/tools/model_generator目录下，且安装好了java运行环境 如果生成文件时出现Warning….信息，则说明icd文件有错误，需要修正 关于libiec61850的使用，查看另一篇文件章61850服务构建流程","categories":[],"tags":[{"name":"61850","slug":"61850","permalink":"http://mijiku.com.cn/blog/tags/61850/"}]},{"title":"61850构建流程","slug":"61850服务构建流程","date":"2021-01-14T01:58:48.549Z","updated":"2021-01-14T08:33:43.607Z","comments":true,"path":"2021/01/14/61850服务构建流程/","link":"","permalink":"http://mijiku.com.cn/blog/2021/01/14/61850服务构建流程/","excerpt":"","text":"要搭建一个61850服务器，可以通过libiec61850这个开源库实现 首先是源码下载，网址为libiec61850.com/libiec61850/downloads,此文使用的是libiec61850-1.4.2.1.tar.gz 接下来是编译12345678tar xvf libiec61850-1.4.2.1.tar.gzcd libiec61850-1.4.2.1mkdir buildcd buildexport TOOLCHAIN /usr/local/arm-6ul/bin/arm-none-gnueabi-cmake -DCMAKE_INSTALL_PREFIX=/opt/libiec61850 ..makemake install 执行完上面一堆操作后，在/opt/libiec61850下面就有编译好的库和头文件了 libiec61850支持多种开发，C/C++,donet,python都可以使用，并且提供了demo，以下是C的用法 以一个61850服务为例，需要实现几点 服务端程序模型文件model.cfg测试程序IEDScount服务端程序可以使用examples/server_example_config_file/server_example_config_file.c 服务端程序需要一个模型配置文件,可以自己写一个，也可以直接使用源码提供的model.cfg具体写法查看另一篇文章-IEC61850建模说明 示例中给出的数据点读取和写入方法是相当粗糙的，这里提供一个比较方便的使用方法，但这个方法有个前提就是，需要有一个icd文件，icd文件可以通过iedout这个软件导出，具体流程是，先将示例代起运行起来，打开IEDScount,点击DiscoverIED,输入设备ip,等获取到数据后，点击SaveSCL,选择保存类型为.icd即可之后编缉icd文件，找到数据点，添加一个属性为sAddr=”1000”,sAddr就是数据点的数字id通过源码中tools/model_generator中的.jar生成model.cfg，就能生成带sAddr的模型配置文件，这样代码中就能使用数字id来定位到数据对象，而不用名字了，具体定位代码如下： 先是读取模型的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105 /* open configuration file */FileHandle configFile = FileSystem_openFile(&quot;model.cfg&quot;, false);if (configFile == NULL) &#123; printf(&quot;Error opening config file!\\n&quot;); return NULL;&#125;/* parse the configuration file and create the data model */IedModel* model = ConfigFileParser_createModelFromConfigFile(configFile);FileSystem_closeFile(configFile);if (model == NULL) &#123; printf(&quot;Error parsing config file!\\n&quot;); return NULL;&#125;iedServer = IedServer_create(model);//接着是模型对象的获取DataAttribute* alarmAttribList[1500]=&#123;0&#125;;//用于存储告警对象DataAttribute* dataAttribList[1500]=&#123;0&#125;;//用于存储数据对象int i;int index=0;/*搜索模型配置中的1500个数据点*/for(i=0;i&lt;1500;i++)&#123; DataAttribute* attrib=NULL; index=40000+i;//数据点的起始地址是40000 attrib = (DataAttribute*) IedModel_getModelNodeByShortAddress(model, index); if(attrib!=NULL) &#123; dataAttribList[i]=attrib; &#125; index=20000+i;//告警点的起始地址是20000 attrib = (DataAttribute*)IedModel_getModelNodeByShortAddress(model, index); if(attrib!=NULL) &#123; alarmAttribList[i]=attrib; &#125;&#125;//之后就可以启动服务了 IedServer_start(iedServer, tcpPort); if (!IedServer_isRunning(iedServer)) &#123; printf(&quot;Starting server failed! Exit.\\n&quot;); IedServer_destroy(iedServer); return NULL; &#125;//服务启动完成后，就需要定时填充实时数据，实时数据是由其它模块采集的，这里只给出示例 while (1) &#123; uint64_t timestamp = Hal_getTimeInMs()-28800000;//减8小时时差 t += 0.1f; for(i=0;i&lt;1500;i++) &#123; IedServer_lockDataModel(iedServer); Timestamp iecTimestamp; Timestamp_clearFlags(&amp;iecTimestamp); Timestamp_setTimeInMilliseconds(&amp;iecTimestamp, timestamp); Timestamp_setLeapSecondKnown(&amp;iecTimestamp, true); /* toggle clock-not-synchronized flag in timestamp */ if (((int) t % 2) == 0) Timestamp_setClockNotSynchronized(&amp;iecTimestamp, true); if(dataAttribList[i]!=NULL) &#123; DataAttribute*attrib=(DataAttribute*)ModelNode_getChild((ModelNode*)dataAttribList[i],&quot;i&quot;); if(attrib) &#123; IedServer_updateInt32AttributeValue(iedServer, attrib, GetDevIValue(0,40000+i));//更新数据到61850服务 &#125; attrib=(DataAttribute*)ModelNode_getChild((ModelNode*)dataAttribList[i]-&gt;parent,&quot;t&quot;); if(attrib) &#123; IedServer_updateTimestampAttributeValue(iedServer,attrib, &amp;iecTimestamp);//更新采集的时间戳 &#125; &#125; if(alarmAttribList[i]!=NULL) &#123; IedServer_updateBooleanAttributeValue(iedServer, alarmAttribList[i], GetDevIValue(0,20000+i));//更新告警状态 DataAttribute*attrib=(DataAttribute*)ModelNode_getChild((ModelNode*)alarmAttribList[i]-&gt;parent,&quot;t&quot;); if(attrib) &#123; IedServer_updateTimestampAttributeValue(iedServer,attrib, &amp;iecTimestamp);//更新告警时间 &#125; &#125; IedServer_unlockDataModel(iedServer); &#125; Thread_sleep(100); &#125;","categories":[],"tags":[{"name":"61850","slug":"61850","permalink":"http://mijiku.com.cn/blog/tags/61850/"}]},{"title":"蓝牙profile简介","slug":"蓝牙profile简介","date":"2020-12-31T08:41:11.458Z","updated":"2020-12-31T08:41:11.458Z","comments":true,"path":"2020/12/31/蓝牙profile简介/","link":"","permalink":"http://mijiku.com.cn/blog/2020/12/31/蓝牙profile简介/","excerpt":"","text":"Bluetooth的一个很重要特性，就是所有的Bluetooth产品都无须实现全部的Bluetooth规范。为了更容易的保持Bluetooth设备之间的兼容，Bluetooth规范中定义了Profile。Profile定义了设备如何实现一种连接或者应用，你可以把Profile理解为连接层或者应用层协议。 比如，如果一家公司希望它们的Bluetooth芯片支援所有的Bluetooth耳机，那么它只要支持HeadSet Profile即可，而无须考虑该芯片与其它Bluetooth设备的通讯与兼容性问题。如果你想购买Bluetooth产品，你应该了解你的应用需要哪些Profile来完成，并且确保你购买的Bluetooth产品支持这些Profile。 在所有的Profile中，有四种是基本的Profile，这些Profile会被其它的Profile使用。它们是： GAP Profile: Generic Access Profile，该Profile保证不同的Bluetooth产品可以互相发现对方并建立连接。 SDAP Profile: Service Discovery Application Profile，通过该Profile，一个Bluetooth设备可以找到其它Bluetooth设备提供的服务，以及查询相关的信息。 SPP Profile: Serial Port Profile，模拟串口通讯 GOEP Profile: Generic Object Exchange Profile，通用对象交换。这个Profile的名字有些费解，它定义的是数据的传输，包括同步，文件传输，或者推送其它的数据。你可以把它理解为内容无关的传输层协议，可以被任何应用用来传输自己定义的数据对象。 另外，Bluetooth还定义了9种应用(usage)Profile。 CTP Profile: Cordless Telephone Profile，无绳电话。 IP Profile: Intercom Profile，这是在两个设备之间建立语音连接，换句话说，把两个昂贵的兰牙设备变成廉价的对讲机。 HS Profile: HeadSet Profile，用于连接耳机。 DNP Profile: Dial-up Networking Profile，用于为PC提供拨号网络功能。 FP Profile: Fax Profile，传真功能。 LAP Profile: LAN Access Profile，使用PPP协议建立局域网。 OPP Profile: Object Push Profile，用于设备之间传输数据对象。 FTP Profile: File Transfer Profile，用于文件传输。 SP Profile: Synchronization Profile，用于不同的Bluetooth设备同步，保持数据的一致性。 Bluetooth的Profile问题是相当复杂的，这些Profile规范在全部的Bluetooth规范中占有了400页的内容","categories":[],"tags":[]},{"title":"蓝牙各版本之间的区别","slug":"蓝牙各版本之前的区别","date":"2020-12-31T08:29:31.819Z","updated":"2020-12-31T08:29:31.820Z","comments":true,"path":"2020/12/31/蓝牙各版本之前的区别/","link":"","permalink":"http://mijiku.com.cn/blog/2020/12/31/蓝牙各版本之前的区别/","excerpt":"","text":"1.1/1.2 可以支持 Stereo 音效的传输要求，但只能够作（单工）方式工作。 2.0 传输率约在 1.8M/s~2.1M/s，可以有（双工）的工作方式。即一面作语音通讯，同时亦可以传输档案/高质素图片。缺点是配置流程复杂和设备功耗较大。 2.1+EDR 主要是解决2.0的缺点。改进过后的连接方式则是会自动使用数字密码来进行配对与连接，举例来说，只要在手机选项中选择连接特定装置，在确定之后，手机会自动列出目前环境中可使用的设备，并且自动进行连结； 蓝牙2.1版加入了Sniff Subrating的功能，透过设定在2个装置之间互相确认讯号的发送间隔来达到节省功耗的目的。一般来说，当2个进行连结的蓝牙装置进入待机状态之后，蓝牙装置之间仍需要透过相互的呼叫来确定彼此是否仍在联机状态，当然，也因为这样，蓝牙芯片就必须随时保持在工作状态，即使手机的其它组件都已经进入休眠模式。为了改善了这样这样的状况，蓝牙2.1将装置之间相互确认的讯号发送时间间隔从旧版的0.1秒延长到0.5秒左右，如此可以让蓝牙芯片的工作负载大幅降低，也可让蓝牙可以有更多的时间可以彻底休眠。根据官方的报告，采用此技术之后，蓝牙装置在开启蓝牙联机之后的待机时间可以有效延长5倍以上。 3.0 核心是”Generic Alternate MAC/PHY”(AMP)，这是一种全新的交替射频技术，允许蓝牙协议栈针对任一任务动态地选择正确射频。通过集成”802.11 PAL”(协议适应层)，蓝牙3.0的数据传输率提高到了大约24Mbps，是2.0的8倍。功耗方面，通过蓝牙3.0高速传送大量数据自然会消耗更多能量，但由于引入了增强电源控制(EPC)机制，再辅以802.11，实际空闲功耗会明显降低，蓝牙设备的待机耗电问题有望得到初步解决。此外，新的规范还具备通用测试方法(GTM)和单向广播无连接数据(UCD)两项技术，并且包括了一组HCI指令以获取密钥长度。 4.0 实际是个三位一体的蓝牙技术，它将三种规格合而为一，分别是传统蓝牙、低功耗蓝牙和高速蓝牙技术，这三个规格可以组合或者单独使用。改进之处主要体现在三个方面，电池续航时间、节能和设备种类上。拥有低成本，跨厂商互操作性，3毫秒低延迟、100米以上超长距离、AES-128加密等诸多特色。","categories":[],"tags":[]},{"title":"linux 蓝牙服务端和客户端编写","slug":"linux下蓝牙服务端和客户端编写","date":"2020-12-31T08:24:13.593Z","updated":"2020-12-31T08:24:13.593Z","comments":true,"path":"2020/12/31/linux下蓝牙服务端和客户端编写/","link":"","permalink":"http://mijiku.com.cn/blog/2020/12/31/linux下蓝牙服务端和客户端编写/","excerpt":"","text":"服务端设置：启动蓝牙设备1hciconfig hci0 up 启动蓝牙可搜索状态1hciconfig piscan 添加蓝牙服务描述，具体的服务需要自已实现，这里只是让外人能搜索出支持什么功能1sdptool add --channel=1 DID SP DUN LAN FAX OPUSH FTP HS HF SAP NAP GN PANU HID CIP CTP A2SRC A2SNK SYNCML NOKID PCSUITE SR1 取消设置pin码，即取消配对功能1hciconfig hci0 noauth 指定pin123456789101112131415161718192021222324252627282930313233修改/etc/bluetooth/hcid.conf options &#123; # Automatically initialize new devices autoinit yes; # Security Manager mode # none - Security manager disabled # auto - Use local PIN for incoming connections # user - Always ask user for a PIN # security auto; # Pairing mode # none - Pairing disabled # multi - Allow pairing with already paired devices # once - Pair once and deny successive attempts pairing multi; pin_helper /usr/bin/bluepin;&#125;新建文件/usr/bin/bluepin,写入以下内容#!/bin/shecho &quot;PIN:1234&quot;也可以是c编译好的文件：#include &lt;stdio.h&gt;int main(int argc, char* argv[])&#123;printf(&quot;PIN:1234&quot;);&#125;编译为bluepin，并复制到/usr/bin 绑定pin码，即添加密码配对功能编辑/var/lib/bluetooth/XX:XX:XX:XX:XX:XX/pincodes （XX:XX:XX:XX:XX:XX为本地蓝牙设备地址）文件内容格式为： XX:XX:XX:XX:XX:XX 1234 （XX:XX:XX:XX:XX:XX为目标设备地址） ###客户端设置：123mknod /dev/rfcomm0 c 216 0chmod 666 /dev/rfcomm0rfcomm bind 0 xx:xx:xx:xx:xx:xx 1 //0表示rfcomm0,xx:xx:xx:xx:xx:xx为服务器地址，1为通道1 以上的配置都需要bluetoothd的支持，如果是嵌入式系统，需要注意有没有这个程序 以下是具体的代码实现，先上服务端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102rfcomm_server.c#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;bluetooth/bluetooth.h&gt;#include &lt;bluetooth/rfcomm.h&gt;int str2ba(const char *str, bdaddr_t *ba)&#123; uint8_t b[6]; const char *ptr = str; int i; for (i = 0; i &lt; 6; i++) &#123; b[i] = (uint8_t) strtol(ptr, NULL, 16); if (i != 5 &amp;&amp; !(ptr = strchr(ptr, &apos;:&apos;))) ptr = &quot;:00:00:00:00:00&quot;; ptr++; &#125;&#125;void baswap(bdaddr_t *dst, const bdaddr_t *src)&#123; unsigned char *d = (unsigned char *) dst; const unsigned char *s = (const unsigned char *) src; int i; for (i = 0; i &lt; 6; i++) d[i] = s[5-i];&#125;int ba2str(const bdaddr_t *ba, char *str)&#123; uint8_t b[6]; baswap((bdaddr_t *) b, ba); return sprintf(str, &quot;%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X&quot;, b[0], b[1], b[2], b[3], b[4], b[5]);&#125;int main(int argc, char **argv)&#123; struct sockaddr_rc loc_addr = &#123; 0 &#125;, rem_addr = &#123; 0 &#125;; char buf[1024] = &#123; 0 &#125;; int s, client, bytes_read; socklen_t opt = sizeof(rem_addr); char write_buf[1204]=&quot;hello world&quot;; char flag = 1; char count=0; // allocate socket s = socket(AF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM); // bind socket to port 1 of the first available // local bluetooth adapter loc_addr.rc_family = AF_BLUETOOTH; loc_addr.rc_bdaddr = *BDADDR_ANY; loc_addr.rc_channel = (uint8_t) 1; bind(s, (struct sockaddr *)&amp;loc_addr, sizeof(loc_addr)); // put socket into listening mode listen(s, 1); // accept one connection client = accept(s, (struct sockaddr *)&amp;rem_addr, &amp;opt); ba2str( &amp;rem_addr.rc_bdaddr, buf ); fprintf(stderr, &quot;accepted connection from %s\\n&quot;, buf); while( flag ) &#123; memset(buf, 0, sizeof(buf));#if 0 // read data from the client bytes_read = read(client, buf, sizeof(buf)); if( bytes_read &gt; 0 ) &#123; printf(&quot;[rcv]:%s\\n&quot;, buf); if(!strcmp(buf,&quot;exit&quot;)) &#123; flag = 0; &#125; // write( client,write_buf,16 ); &#125; usleep(5000);#endif#if 1//write data to clientstrcpy( buf, &quot;abcdefgh&quot; );bytes_read = 9; write( client,buf,bytes_read ); usleep(50000);#endif &#125; // close connection close(client); close(s); return 0;&#125; 接着是客户端代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546rfcomm_client.c#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt;int main( int argc, char **argv ) &#123; int fd ; unsigned char buff[64] = &quot;hello&quot;; char read_buff[128] = &#123;0&#125;; int read_n; int write_n; fd = open( &quot;/dev/rfcomm0&quot;,O_RDWR); if( fd&lt;0 ) printf( &quot;open rfcomm0 error\\n&quot; ); while(1) &#123;#if 0 // printf( &quot;write hello to rfcomm\\n&quot; ); write_n = write( fd, buff, 64 ); if( write_n&lt;0) printf( &quot;write error\\n&quot; ); else if(write_n==0) printf( &quot;write nothing\\n&quot; ); else printf( &quot;write %d byte\\n&quot;,write_n ); // sleep(1);#endif#if 1 memset( read_buff, 0, sizeof(read_buff) ); read_n = read( fd, read_buff, sizeof(read_buff) ); if( read_n &gt; 0 ) &#123; printf( &quot;[receive]:%s\\n&quot;,read_buff ); &#125; usleep(50000); #endif &#125; close(fd);&#125; 以下是一个扫描蓝牙设备的demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/socket.h&gt; #include &lt;bluetooth/bluetooth.h&gt; #include &lt;bluetooth/hci.h&gt; #include &lt;bluetooth/hci_lib.h&gt; int main(int argc, char **argv) &#123; inquiry_info *ii = NULL; int max_rsp, num_rsp; int dev_id, sock, len, flags; int i; char addr[19] = &#123; 0 &#125;; char name[248] = &#123; 0 &#125;; dev_id = hci_get_route(NULL); sock = hci_open_dev( dev_id ); if (dev_id &lt; 0 || sock &lt; 0) &#123; perror(&quot;opening socket&quot;); exit(1); &#125; len = 8; max_rsp = 255; flags = IREQ_CACHE_FLUSH; ii = (inquiry_info*)malloc(max_rsp * sizeof(inquiry_info)); num_rsp = hci_inquiry(dev_id, len, max_rsp, NULL, &amp;ii, flags); if( num_rsp &lt; 0 ) perror(&quot;hci_inquiry&quot;); for (i = 0; i &lt; num_rsp; i++) &#123; ba2str(&amp;(ii+i)-&gt;bdaddr, addr); memset(name, 0, sizeof(name)); if (hci_read_remote_name(sock, &amp;(ii+i)-&gt;bdaddr, sizeof(name), name, 0) &lt; 0) strcpy(name, &quot;[unknown]&quot;); printf(&quot;%s %s\\n&quot;, addr, name); &#125; free( ii ); close( sock ); return 0; &#125;","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://mijiku.com.cn/blog/tags/linux/"}]},{"title":"linux下虚拟串口的使用","slug":"linux下虚拟串口的使用","date":"2020-12-31T08:06:35.251Z","updated":"2020-12-31T08:06:35.251Z","comments":true,"path":"2020/12/31/linux下虚拟串口的使用/","link":"","permalink":"http://mijiku.com.cn/blog/2020/12/31/linux下虚拟串口的使用/","excerpt":"","text":"在linux下开发串口程序的时候，都要接上usb串口，连到设备上调试，很不方便，windows上有串口虚拟助手，linux下也有，叫socat,安装很简单1apt-get install socat 模拟两个串口1234socat -d -d pty pty2020/12/25 11:30:13 socat[16005] N PTY is /dev/pts/32020/12/25 11:30:13 socat[16005] N PTY is /dev/pts/42020/12/25 11:30:13 socat[16005] N starting data transfer loop with FDs [5,5] and [7,7] 会生成两个串口的设备文件/dev/pts/3和/dev/pts/4，可以创建软链接，方便程序开发12ln -s /dev/pts/3 /dev/ttyS1ln -s /dev/pts/4 /dev/ttyS2 用以上方式就能很方便地调试基于串口通讯的程序了 socat可不止这么点功能，还可以将物理串口映射到虚拟串口上，比如物理串口是/dev/ttyS31socat -d -d /dev/ttyS3 pty 除了可以映射串口，还可以映射到tcp口上1socat /dev/ttyS3 tcp-listen:8888","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://mijiku.com.cn/blog/tags/linux/"}]},{"title":"Linux下将目录打包为镜像","slug":"linux下将根文件系统打包为镜像","date":"2020-12-31T07:39:19.966Z","updated":"2020-12-31T07:39:19.966Z","comments":true,"path":"2020/12/31/linux下将根文件系统打包为镜像/","link":"","permalink":"http://mijiku.com.cn/blog/2020/12/31/linux下将根文件系统打包为镜像/","excerpt":"","text":"创建镜像文件，指定镜像原始大小为1G1dd if=/dev/zero of=linux-rootfs.img bs=1M count=1024 /dev/zero：为虚拟盘的名字。linux-rootfs.img为你的穿建的镜像文件。bs=1Mcount=1024为此镜像的大小 设置镜像格式1mkfs.ext4 linux-rootfs.img 将镜像挂载为一个目录1mount linux-rootfs.img tmp 将文件复制到镜像目录12cp -rfp rootfs/ tmpumount tmp 调整镜像大小12e2fsck -p -f linux-rootfs.imgresize2fs -M linux-rootfs.img","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://mijiku.com.cn/blog/tags/linux/"}]},{"title":"搭建支持http访问的git服务","slug":"搭建支持http访问的git服务","date":"2020-12-31T07:34:00.127Z","updated":"2020-12-31T07:34:00.127Z","comments":true,"path":"2020/12/31/搭建支持http访问的git服务/","link":"","permalink":"http://mijiku.com.cn/blog/2020/12/31/搭建支持http访问的git服务/","excerpt":"","text":"由于公司使用代理上网，无法通过ssh的方式clone在自己服务器上的仓库代码，所以研究了这个方法来使用git 创建git仓库12345$ cd /home$ mkdir git$ cd /home/git$ git init --bare test.git //初始化仓库$ chown -R www-data:www-data ../git //使用http访问的话，一般指定www-data用户，具体设置哪一个，需要看后面的nginx服务怎么配 有了仓库之后，就可以使用 git clone www-data@127.0.0.1/test.git 拉取代码了，下面开始搭建http服务器 需要先安装nginx和fcgiwrap,ubuntu下安装命令是12apt-get install nginxapt-get install fcgiwrap 添加nginx的配置文件1234567891011121314151617181920vim /etc/nginx/conf.d/git.confserver&#123;listen 80; server_name localhost; client_max_body_size 100m; auth_basic &quot;git&quot;; auth_basic_user_file /home/git//pass.db; location ~(/.*) &#123; fastcgi_pass unix:/tmp/cgi.sock; fastcgi_param SCRIPT_FILENAME /usr/lib/git-core/git-http-backend; fastcgi_param PATH_INFO $1; fastcgi_param GIT_HTTP_EXPORT_ALL &quot;&quot;; fastcgi_param GIT_PROJECT_ROOT /home/git; fastcgi_param REMOTE_USER $remote_user; include fastcgi_params; &#125;&#125; 以上配置，需要注意/usr/lib/git-core/git-http-backend，当前git的版本不一样，可能位置也不一样，需要提前检查下 修改nginx的工作用户nginx默认是nobody, 这里我们改为www-data,123vim /etc/nginx/nginx.conf#user nobody;user www-data; 重新启动nginx1/etc/init.d/nginx restart 生成用户密码1htpasswd -c -d /home/git/passwd.db test 输入密码之后就可以通过git clone http://127.0.0.1/test.git下载代码了,用户密码为刚才设置的密码对，如果忘记了，就删掉重来吧","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://mijiku.com.cn/blog/tags/linux/"}]},{"title":"sftp服务器搭建","slug":"sftp服务器搭建","date":"2020-12-30T11:40:02.824Z","updated":"2020-12-30T11:40:02.824Z","comments":true,"path":"2020/12/30/sftp服务器搭建/","link":"","permalink":"http://mijiku.com.cn/blog/2020/12/30/sftp服务器搭建/","excerpt":"","text":"sftp和ftp是两种不同的协议,sftp是ssh内含的协议，只要sshd服务器启动了，它就可用，它本身不需要ftp服务器启动。 1、查看软件版本,想sftp服务用户只能访问特定的文件目录,版本需要4.8以上 12[root@localhostftp]# ssh -V OpenSSH_8.1p1, LibreSSL 2.7.3 2、新增用户,限制用户只能通过sftp访问 1[root@localhostftp]# useradd -m -d /home/useradmin -s /sbin/nologin useradmin 3、限制用户通过sftp登录进来时只能进入主目录，修改/etc/ssh/sshd_config文件 12345678[root@localhostftp]# vim /etc/ssh/sshd_config #Subsystem sftp /usr/libexec/openssh/sftp-server Subsystem sftp internal-sftp Match User cxjbb ChrootDirectory /home/cxjbb X11Forwarding no AllowTcpForwarding no ForceCommand internal-sftp 4、重启sshd服务 1[root@localhostftp]#service sshd restart 5、测试访问 123456789root@10.1.1.200:test# sftp -oPort=22 useradmin@10.0.100.175 Connecting to 10.0.100.175... useradmin@10.0.100.175&apos;s password: Read from remote host 10.1.6.175: Connection reset by peer Couldn&apos;t read packet: Connection reset by peer 发现连接不上,查看日志 [root@localhostftp]# tail /var/log/messages Jan 6 11:41:41 localhost sshd[4907]: fatal: bad ownership or modes forchroot directory &quot;/opt/ftp/dave&quot; Jan 6 11:41:41 localhost sshd[4905]: pam_unix(sshd:session): session closed 6、解决方法: 目录权限设置上要遵循2点： ChrootDirectory设置的目录权限及其所有的上级文件夹权限，属主和属组必须是root； ChrootDirectory设置的目录权限及其所有的上级文件夹权限，只有属主能拥有写权限，权限最大设置只能是755。 如果不能遵循以上2点，即使是该目录仅属于某个用户，也可能会影响到所有的SFTP用户。 123456[root@localhostftp]# ll total 4 drwxr-xr-x 3 dave dave 4096 Jan 5 13:06 useradmin [root@localhostftp]# chown root:root useradmin [root@localhostftp]# chmod 755 useradmin [root@localhostftp]# ll total 4 drwxr-xr-x 3 root root 4096 Jan 5 13:06 useradmin 然后在测试通过 1234567891011root@10.1.1.200:test# sftp -oPort=22 useradmin@10.0.100.175 Connecting to 10.0.100.175... dave@10.0.100.175&apos;s password: sftp&gt;ls test sftp&gt;cd.. sftp&gt;ls test sftp&gt;cdtest sftp&gt;ls 1.txt sftp&gt; get 1.txt Fetching/test/1.txt to 1.txt /test/1.txt 可以看到已经限制用户在家目录,同时该用户也不能登录该机器。 7、linux下sftp关闭步骤 linux下ftp分为ftp和sftp，sftp属于带权限的传输方式,传输过程加密，从原理上看,sftp属于ssh的一部分。 如果不需要sftp需要关闭,执行如下方法: 编辑 /etc/ssh/sshd_config 文件 vim /etc/ssh/sshd_config 找到 PasswordAuthentication 项，将值由yes 修改为no 以root 权限重启SSH，命令： /etc/init.d/ssh restart","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://mijiku.com.cn/blog/tags/linux/"}]},{"title":"嵌入式linux下进程内存占用分析","slug":"嵌入式linux下进程内存占用分析","date":"2019-11-27T08:31:27.000Z","updated":"2019-11-27T09:41:16.674Z","comments":true,"path":"2019/11/27/嵌入式linux下进程内存占用分析/","link":"","permalink":"http://mijiku.com.cn/blog/2019/11/27/嵌入式linux下进程内存占用分析/","excerpt":"","text":"在嵌入式linux下，可以通过cat /proc/进程号/smas查看该进程的内存使用情况在smaps文件中，每一条记录（如下所示）表示进程虚拟内存空间中一块连续的区域。其中第一行从左到右依次表示地址范围、权限标识、映射文件偏移、设备号、inode、文件路径。smaps文件部分内容格式：12345678910111213141516171819202122232425262728293031address perms offset dev inode pathname2e37a000-2e3b5000 r-xp 00000000 b3:01 4151 /opt/qt4.8.6/lib/libQtXml.so.4.8.6Size: 236 kBRss: 52 kBPss: 52 kBShared_Clean: 0 kBShared_Dirty: 0 kBPrivate_Clean: 52 kBPrivate_Dirty: 0 kBReferenced: 52 kBAnonymous: 0 kBAnonHugePages: 0 kBSwap: 0 kBKernelPageSize: 4 kBMMUPageSize: 4 kBLocked: 0 kB2e3b5000-2e3bc000 ---p 0003b000 b3:01 4151 /opt/qt4.8.6/lib/libQtXml.so.4.8.6Size: 28 kBRss: 0 kBPss: 0 kBShared_Clean: 0 kBShared_Dirty: 0 kBPrivate_Clean: 0 kBPrivate_Dirty: 0 kBReferenced: 0 kBAnonymous: 0 kBAnonHugePages: 0 kBSwap: 0 kBKernelPageSize: 4 kBMMUPageSize: 4 kBLocked: 0 kB 每一列的含义：address - This is the starting and ending address of the region in the process’s address spacepermissions - This describes how pages in the region can be accessed. There are four different permissions: read, write, execute, and shared. If read/write/execute are disabled, a - will appear instead of the r/w/x. If a region is not shared, it is private, so a p will appear instead of an s. If the process attempts to access memory in a way that is not permitted, a segmentation fault is generated. Permissions can be changed using the mprotect system call.offset - If the region was mapped from a file (using mmap), this is the offset in the file where the mapping begins. If the memory was not mapped from a file, it’s just 0.device - If the region was mapped from a file, this is the major and minor device number (in hex) where the file lives.inode - If the region was mapped from a file, this is the file number.pathname - If the region was mapped from a file, this is the name of the file. This field is blank for anonymous mapped regions. There are also special regions with names like [heap], [stack], or [vdso]. [vdso] stands for virtual dynamic shared object. It’s used by system calls to switch to kernel mode 接下来8个字段的含义分别如下： Size：表示该映射区域在虚拟内存空间中的大小。Rss：表示该映射区域当前在物理内存中占用了多少空间 Shared_Clean：和其他进程共享的未被改写的page的大小Shared_Dirty： 和其他进程共享的被改写的page的大小Private_Clean：未被改写的私有页面的大小。Private_Dirty： 已被改写的私有页面的大小。referenced:当前能够被引用到的内存,以及当前可达的内存.Anonymous:表示当前没有与文件联系在一块的内存,也就是说没有作为交换Swap：表示非mmap内存（也叫anonymous memory，比如malloc动态分配出来的内存）由于物理内存不足被swap到交换空间的大小。Pss：该虚拟内存区域平摊计算后使用的物理内存大小(有些内存会和其他进程共享，例如mmap进来的)。比如该区域所映射的物理内存部分同时也被另一个进程映射了，且该部分物理内存的大小为1000KB，那么该进程分摊其中一半的内存，即Pss=500KB。 以下是快速计算的命令，也可以通过cat /proc/进程号/status查看计算某进程的内存实际占用如进程号为12713,则1cat /proc/12713/smaps |grep ^Rss|awk &apos;&#123;s+=$2&#125;END&#123;print &quot;sum=&quot;s&#125;&apos; 计算某进程的虚拟内存占用1cat /proc/12713/smaps |grep ^Size|awk &apos;&#123;s+=$2&#125;END&#123;print &quot;sum=&quot;s&#125;&apos; awk将输出的数据进行统计","categories":[],"tags":[]},{"title":"使用mongoose搭建嵌入式网页服务器(二)","slug":"使用mongoose搭建嵌入式网页服务器-二","date":"2019-05-21T05:00:39.000Z","updated":"2019-05-21T05:00:39.075Z","comments":true,"path":"2019/05/21/使用mongoose搭建嵌入式网页服务器-二/","link":"","permalink":"http://mijiku.com.cn/blog/2019/05/21/使用mongoose搭建嵌入式网页服务器-二/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"使用mongoose搭建嵌入式网页服务器(一)","slug":"使用mongoose搭建嵌入式网页服务器","date":"2019-05-21T05:00:03.000Z","updated":"2019-05-21T07:27:29.459Z","comments":true,"path":"2019/05/21/使用mongoose搭建嵌入式网页服务器/","link":"","permalink":"http://mijiku.com.cn/blog/2019/05/21/使用mongoose搭建嵌入式网页服务器/","excerpt":"","text":"下载源码1git clone https://github.com/cesanta/mongoose 测试demo123cd mongoose/examples/simplest_web_servermake./simplest_web_server 以上，就是一个最简单的web服务器了不过只显示了当前目录下的文件，接下来我们就基于这个demo，制作自己的小网站 创建一个目录web，将mongoose/mongoose.c,mongoose/mongoose.h,mongoose/examples/simplest_web_server/simplest_web_server.c 复制到这个目录下 之后编写编译脚本，也可以写Makefile,随意〜〜以下是我的编译脚本build.sh1gcc mongoose.c simplest_web_server.c -o web build.sh权限，chmod 777 build.sh以后就可以执行./build.sh编译了 编写自己的网页修改simplest_web_server.c,代码如下：12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;mongoose.h&quot; static const char *s_http_port = &quot;8000&quot;;static struct mg_serve_http_opts s_http_server_opts; static void ev_handler(struct mg_connection *nc, int ev, void *p) &#123; if (ev == MG_EV_HTTP_REQUEST) &#123; struct http_message *msg=(struct http_message*)p; //限制浏览器的入口，只能访问/,或者/index,都会指向index.html这个文件 if(mg_vcmp(&amp;msg-&gt;uri,&quot;/index&quot;)==0 ||mg_vcmp(&amp;msg-&gt;uri,&quot;/&quot;)==0) &#123; mg_http_server_file(nc, msg,&quot;index.html&quot;,mg_mk_str(&quot;text/html&quot;),mg_mk_str(&quot;&quot;)); &#125; &#125;&#125; int main(void) &#123; struct mg_mgr mgr; struct mg_connection *nc; mg_mgr_init(&amp;mgr, NULL); printf(&quot;Starting web server on port %s\\n&quot;, s_http_port); nc = mg_bind(&amp;mgr, s_http_port, ev_handler);//绑定端口与事件处理器 if (nc == NULL) &#123; printf(&quot;Failed to create listener\\n&quot;); return 1; &#125; mg_set_protocol_http_websocket(nc); s_http_server_opts.document_root = &quot;.&quot;; // 设置网页的根目录 s_http_server_opts.enable_directory_listing = &quot;no&quot;;//关闭本地文件的显示 for (;;) &#123; mg_mgr_poll(&amp;mgr, 1000); &#125; mg_mgr_free(&amp;mgr); return 0;&#125; 另外编辑一个index.html文件1234567&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;H2&gt;Hello world!&lt;H2&gt;&lt;/body&gt;&lt;/html&gt; 执行./build.sh再执行./web打开浏览器，输入http://127.0.0.1:8000/即可看到网页内容 如果是放在板子上运行，只需将build.sh的编译命令改下，重新编译后，把执行文件和网页丢板上就好，比起boa来， 这个更容易懂些，也容易扩展些 以上是普通静态网页的做法，后面将会更新动态网页的写法，敬请期待〜〜","categories":[],"tags":[]},{"title":"嵌入式linux下使用mutt发送带附件的邮件","slug":"嵌入式linux下使用mutt发送带附件的邮件","date":"2019-05-21T00:37:56.000Z","updated":"2019-05-21T06:26:56.409Z","comments":true,"path":"2019/05/21/嵌入式linux下使用mutt发送带附件的邮件/","link":"","permalink":"http://mijiku.com.cn/blog/2019/05/21/嵌入式linux下使用mutt发送带附件的邮件/","excerpt":"","text":"之前已经使用msmtp成功发送了邮件，但如果要发送带附件的邮件，就需要配合mutt了 编译mutt编译mutt前，要先编译openssl和ncurses这两个库，编译方法就不在这说了在mutt官网上虽然有下载链接，但下不了，还好在github上找到了项目的源码，地址是https://github.com/muttmua/mutt可以使用git clone命令，或者直接下载zip包下载后进入到源码目录，执行12345./prepare #生成configure./configure --host=arm-linux --prefix=/opt/mutt --with-curses=/opt/ncurses -with-ssl CFLAGS=&quot;-I/opt/ncurses/include -I/opt/ncurses/include/ncurses -I/opt/openssl -L/opt/openssl/lib -lssl -lcrypto -L/opt/ncurses/lib&quot; LD=arm-linux-ld --disable-doc --disable-filemonitormake &amp;&amp;make install 将编译生成的mutt丢到板子上的/bin目录这里提供一个现成的点击下载：mutt.tar.gz执行mutt的时候有可能会出现vt100这类的错误,解决方法如下 12export TERM=vt100export TERMINFO=/usr/share/terminfo/v 如果系统中没有/usr/share/terminfo/v/vt100这个文件，就需要将pc上的文件复制过来了 使用mutt发邮件发送邮件前需要准备下配置文件 /etc/msmpt.conf123456789101112host smtp.163.com port 465auth logintls ontls_starttls offtls_certcheck off #关闭cert证书的检测，嵌入式下不关闭会有问题proxy_host 192.168.162.85 #这里使用了代理from xxxx@163.comuser xxxx@163.compassword xxxxxxtimeout 10logfile /var/log/msmtp.log /etc/mutt.conf123456set sendmail=&quot;/bin/msmtp -C /etc/msmtp.conf&quot;set use_from=yesset realname=&quot;xxxxx&quot;set editor=&quot;vi&quot;set from=xxxx@163.com #这里必须和msmtp的一样set envelope_from=yes 准备好配置文件后，就可以试试发送邮件了echo “hello world!”|mutt -s “hello,boy” 277835572@qq.com -a hello.jpg -F /etc/mutt.conf hello world!是邮件的内容，hello,boy是邮件的主题，后面接着接收人邮件地址，hello.jpg是附件，最后指定mutt的配置文件，这样就算大功告成啦 也可以预先把邮件内容写到某个文件中cat mail.txt |mutt -s “hello” 277835572@qq.com -a hello.jpg -F /etc/mutt.conf","categories":[],"tags":[]},{"title":"嵌入式linux下使用msmtp发送邮件","slug":"嵌入式linux下使用msmtp发送邮件","date":"2019-05-13T10:30:17.000Z","updated":"2019-05-21T06:19:44.297Z","comments":true,"path":"2019/05/13/嵌入式linux下使用msmtp发送邮件/","link":"","permalink":"http://mijiku.com.cn/blog/2019/05/13/嵌入式linux下使用msmtp发送邮件/","excerpt":"","text":"编译msmtparm gcc版本:4.8.3源码地址:https://marlam.de/msmtp/download/下载后解压，执行以下命令生成Makefile123./configure --host=arm-linux --prefix=/opt/msmtp libssl_CFLAGS=&quot;-I/share/env-dtu/include&quot; libssl_LIBS=&quot;-L/share/env-dtu/lib -lssl -lcrypto&quot; --with-tls=openssl make 虽然官方推荐使用gnutls作为tls的加密组件，但总是编译不过，只好使用opensslopenssl的编译方法这里就不提供了编译完成后，把src下的msmtp复制到开发板中的/bin下，编译这事就算完了这里提供一个现成的点击下载：msmtp.tar.gz 使用msmtp接下来是使用msmtp发送邮件首先准备好一个配置文件,命名为msmtp.conf，存放在/etc下，内容为：1234567891011host smtp.163.com #邮箱服务器地址port 465 #邮箱端口，一般465就是ssl加密端口auth login #启用登陆功能，现代服务器一般都需要验证的tls on #启用ssl加密码tls_starttls off #关闭starttls功能，一般只在非加密码环境下使用tls_certcheck off #关闭cert证书的检测from xxxx@163.com #发件人邮箱user xxxx@163.com #邮箱账号password xxxxxx #邮箱密码timeout 10 #发送超时logfile /var/log/msmtp.log #设置日志记录文件 接下来编写一封邮件，命名为mail,格式如下：123456Date:Mon May 13 18:16:30 UTC 2019Form:xxxx@163.comTo:taoyb@eastups.comSubject:testthis is a test! 第一行时间通过date命令得知，邮件内容之前要空一行之后执行1msmtp -C /etc/msmtp.conf -t &lt;mail -C 指定配置文件-t 用于接收mail的内容 以上就是使用msmtp发送163邮件的方法,接下来是一些常用操作 使用代理服务器发送邮件代理只能使用sock v5的1msmtp -C /etc/msmtp.conf --proxy-host=192.168.162.85 -t &lt;mail 发送不加密的邮件编缉配置文件，将port 改为25,tls改为off1msmtp -C /etc/msmtp.conf -t &lt;mail","categories":[],"tags":[]},{"title":"大量time wait的处理方法","slug":"大量time-wait的处理方法","date":"2019-04-30T07:02:08.000Z","updated":"2019-04-30T07:14:11.418Z","comments":true,"path":"2019/04/30/大量time-wait的处理方法/","link":"","permalink":"http://mijiku.com.cn/blog/2019/04/30/大量time-wait的处理方法/","excerpt":"","text":"有一天，自己的开发的服务软件连接不上了，ssh进到系统，netstat -an发现存在大量time wait信息在网上查询到如下描述：123在高并发短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。 解决方法如下:将以下内容写入/etc/sysctl.conf1234net.ipv4.tcp_syncookies = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_fin_timeout = 30 然后执行 /sbin/sysctl -p 让参数生效。 net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭； net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭； net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。 net.ipv4.tcp_fin_timeout 修改系統默认的 TIMEOUT 时间","categories":[],"tags":[]},{"title":"嵌入式syslog编译与使用","slug":"嵌入式syslog编译与使用","date":"2019-04-30T06:37:07.000Z","updated":"2019-04-30T06:59:12.006Z","comments":true,"path":"2019/04/30/嵌入式syslog编译与使用/","link":"","permalink":"http://mijiku.com.cn/blog/2019/04/30/嵌入式syslog编译与使用/","excerpt":"","text":"busybox下的syslogd不能同时监控多个log，所以需要自己编译一个 syslog该工具在inetutils工具包内首先下载安装包，然后解压，编译1234wget ftp://ftp.gnu.org/gnu/inetutils/inetutils-1.5.tar.gztar xvf inetutils-1.5.tar.gz &amp;&amp; cd inetutils-1.5CC=arm-none-linux-gnueabi-gcc LDFLAGS=-static ./configure --disable-clients --disable-ipv6 --disable-ncurses --host=arm --prefix=/opt/inetutilsmake 之后可在src/下找到syslogd，将之复制到开发板的/sbin目录内 但syslog不支持多线程打印，当两条线程同时使用时，需要自行加锁rsyslog是syslog的升级版，支持多线程编译步骤一样，但需要多安装一些库,这里就不多说了 syslog可以通过配置文件控制日志的输出，但不能指定日志的大小所以需要用到logrotate命令 logrotatelogrotate是linux中日志管理的重要工具，它可以自动对日志进行截断（或轮循）、压缩以及删除旧的日志文件。在发行版的桌面或者服务器linux系统中这个工具安装一般都是比较容易，或者默认已经自带，但是嵌入式系统一般需要通过源码来自己构建。 先安装编译依赖工具12apt-get install libtool-binapt-get install autopoint 构建POPT库由于logrotate依赖于POPT库，所以要生成logrotate需要先构建POPT库，然后再利用POPT库构建logrotate。下载最新的master分支源码包,并编译1git clone https://github.com/devzero2000/POPT 由于源码是基于autotools编译的，所以需要安装以下两个依赖工具12apt-get install libtool apt-get install autoconf 第一次编译需要先生成configure,执行以下命令1./autogen.sh 之后就可以使用configure这个程序来生成Makefile了，比如下面就是生成 arm版的命令123./configure --prefix=/opt/POPT --host=arm-linuxmakemake install 构建好后会在/opt/POPT 生成“include lib share” 三个目录，其中lib目录有logrotate编译和运行需要的库文件，include目录有我们编译logrotate需要的头文件。 构建logrotate下载最新的源码logrotate,并编译12345git clone https://github.com/logrotate/logrotate ./autogen.sh#./configure --host=arm-linux --prefix=/opt/logrotate LDFLAGS=-L/opt/POPT/lib CPPFLAGS=-I/opt/POPT/includemake make install 其中LDFLAGS指定logrotate编译依赖库lpopt路径；而CPPFLAGS指定logrotate编译依赖头文件popt.h路径。构建好后会在/opt/logrotate目录生成sbin/logrotate文件。 将/opt/POPT/lib/libpopt.so.0.0.0 复制到开发板的/lib下，并将名称改为libpopt.so.0将/opt/logrotate/sbin/logrotate 复制到开发板的/sbin目录 编写一个配置文件,存放到开发板的/etc目录下，名称为logrotate.cfg内容如下：1234567/var/log/testlog.log &#123; size=100k rotate 2 postrotate /usr/bin/killall -HUP syslogd endscript&#125; 脚本的功能为监控/var/log/testlog.log,当该文件大于100k时，备份，最多备份2次，每次备份时，会kill掉syslogd，不过syslogd是会自动重启的不用担心 之后还需要启动一个定时任务来周期性调用logrotate命令 首先在开发板上创建/etc/cron目录开机脚本写上12crond -c /etc/croncrontab -c /etc/cron /etc/cron/logrotate 开机脚本每个系统都不太一样，就不说了之后编写一个cron的配置文件放在/etc/cron目录下，文件名为logrotate内容为:1* * * * * logrotate /etc/logrotate.cfg 内容的意思是每分钟执行一次logrotate，这样就可以自动备份转存日志了","categories":[],"tags":[]},{"title":"使用git上传并自动部署服务端代码","slug":"使用git上传并自动部署服务端代码","date":"2019-04-29T00:15:31.000Z","updated":"2019-04-29T02:18:18.412Z","comments":true,"path":"2019/04/29/使用git上传并自动部署服务端代码/","link":"","permalink":"http://mijiku.com.cn/blog/2019/04/29/使用git上传并自动部署服务端代码/","excerpt":"","text":"一、git服务器搭建安装gitapt-get install git 创建git用户12adduser gitpasswd git //修改git用户密码 创建git仓库123456789$ cd /home$ mkdir git$ mkdir ./git/.ssh$ touch./git/.ssh/authorized_keys$ cd /home/git$ git init --bare test.git //初始化仓库$ chown -R git:git ../git$ chmod 700 .ssh // 需要设置成700，否则公钥认证会提示 (Permission denied)$ chmod 600 .ssh/authorized_key // 需要设置成600，否则公钥认证会提示 (Permission denied) 使用git用户生成git密钥把客户端的公钥（id_rsa.pb文件内容）添加到authorized_keys文件，git push操作就不需要每次都输入密码了） 123$ sudo -u git ssh-keygen -t rsa -C “test@qq.com” //生成密钥$ cd /home/git/.ssh$ cat id_rsa.pub&gt;&gt;authorized_keys //把公钥加入authorized_keys文件 创建web目录123$ cd /home$ git clone ssh://git@127.0.0.1/home/git/test.git //因为我的web服务器与git服务器是同一台主机所以使用127.0.0.1,如果不是放在同一台主机的请使用公网ip$ chown -R git:git test //test目录拥有设为git(如果test有其他的拥有者，可以把git加入其目录拥有者的组) 编写自动更新钩子12$ cd /home/git/test.git/hooks/$ vim post-receive 内容如下：12345#!/bin/shDIR=/home/testgit --work-tree=$&#123;DIR&#125; clean -fd# 直接强制检出 git --work-tree=$&#123;DIR&#125; checkout --force 给钩子文件添加执行权限12$ cd /home/git/test.git/hooks/$ chmod +x post-receive //给钩子文件添加执行权限 二、客户端测试验证生成客户端密钥12ssh-keygen -t rsa -C “test@qq.com” //生成密钥ssh-copy-id -i ~/.ssh/id_rsa.pub 服务器ip //将密钥上传到服务，以后就可以不用输密码了 然后把git仓库拷贝下来1git clone ssh://git@123.456.78.9/home/git/test.git 测试操作git push完成后git自动对web目录做git pull操作 123456cd testgit pull origin mastertouch test.txtgit add .git commit -m&apos;test&apos;git push origin master","categories":[],"tags":[]},{"title":"syslog使用方法","slug":"syslog使用方法","date":"2019-04-28T03:59:34.000Z","updated":"2019-04-28T06:51:19.019Z","comments":true,"path":"2019/04/28/syslog使用方法/","link":"","permalink":"http://mijiku.com.cn/blog/2019/04/28/syslog使用方法/","excerpt":"","text":"三个函数的原型和说明:123void openlog(char *ident,int option,int facility);void syslog(int priority,char *format, ...);void closelog(); log以时间，标题，内容组成log的生成路径可以通过修改配置文件来改变以下先看代码写法：12345678910111213141516#include &lt;syslog.h&gt;#include &lt;pthread.h&gt;//如果使用的是syslogd服务，则需要添加多线程锁，如果是使用rsyslog,则不需要pthread_mutex_t infoLock=PTHREAD_MUTEX_INITIALIZER;#define NoticeLog(format,args...) \\&#123; \\ pthread_mutex_lock(&amp;infoLock); \\ openlog(&quot;demo&quot;,0,LOG_LOCAL0); \\ syslog(LOG_INFO,format, ## args); \\ pthread_mutex_unlock(&amp;infoLock); \\&#125;int main()&#123; NoticeLog(&quot;a=%s&quot;,&quot;1111111111&quot;); &#125; 以上代码会生成的以下这样的logApr 28 11:00:41.850 demo: 1111111111 如果没有配置文件的话，log默认会输出到/var/log/message下 配置文件的格式为 facility.priority action，这些字段的定义如下： facility 指定产生消息的子系统。facility 有效的关键字有 auth、authpriv、cron、daemon、kern、lpr、mail、news、syslog、user、uucp 以及 local0 到 local7。 priority 指定消息的最低严重性，即此优先级和高于此优先级的消息将由这个规则匹配。priority 的有效关键字有 debug、info、notice、warning、err、crit、alert 和 emerg。 action action 字段可以是文件名、tty（如 /dev/console）、以 @ 为前缀的远程机器、以逗号分隔的用户列表，或是 * 以表明向所有登录用户发送消息。最常见的操作是一个简单的文件名。 以下是例子：1234567891011local0.info /root/app/data/info.loglocal0.info @192.168.162.245local0.notice /root/app/data/info1.loglocal1.* /root/app/data/notice.loglocal2.* /root/app/data/debug.loglocal3.* /root/app/data/warning.loglocal4.* /root/app/data/error.loglocal5.* /root/app/data/crit.loglocal6.* /root/app/data/alert.logkern.* /var/log/messageuser.* /var/log/message local0-7一般由用户自定义使用配置文件上配置有@ip的，则是将log发送到指定的机器上，默认是发到514的udp端口其它则是将log写到不同文件中 如下代码的意思是，将log输出到locall0.notice配置对应的文件里其中demo是此条log的名称，可以自定义12openlog(&quot;demo&quot;,0,LOG_LOCAL0); syslog(LOG_NOTICE,format, ## args); 系统一般会启动一个syslogd进程，不带配置文件的，所以我们需要修改启动项添加syslogd -f /etc/syslog.cfg -n &amp; 作为启动条件当更新了配置文件以后，也需要手动重新启动syslogd服务 log的文件大小是不作限制的，所以还需要配合logrotate 使用","categories":[],"tags":[]},{"title":"配置工具信息","slug":"配置工具信息","date":"2019-04-26T03:17:57.000Z","updated":"2021-01-11T08:50:38.482Z","comments":true,"path":"2019/04/26/配置工具信息/","link":"","permalink":"http://mijiku.com.cn/blog/2019/04/26/配置工具信息/","excerpt":"","text":"PS：每个版本都对应于SDK版本，不一定都兼容 版本：20210111最低SDK版本：16改动：1.添加mqtt搜索信息分页点击下载：配置工具-20210111 版本：20201124最低SDK版本：16改动：1.添加mqtt搜索信息分组点击下载：配置工具-20201124 版本：20201009最低SDK版本：16改动：1.添加mqtt搜索方式点击下载：配置工具-20201009 版本：201901227最低SDK版本：16改动：1.自定义数据监控添加曲线功能2.加速配置读取点击下载：配置工具-20191227 版本：201900708最低SDK版本：16改动：1.添加自定义的数据监控配置2.修复读取设备配置表不刷新问题点击下载：配置工具-20190708 版本：20190428最低SDK版本：16改动：1.添加目标机器的syslog展示与过滤，需要本机作为log的服务器，所以使用的时候目标机器要能ping通本机点击下载：配置工具-20190428 版本：20190426最低SDK版本：16改动：1.实时数据页现在只传输当前选择的设备数据，持续一分钟可通过点击表格内的点来刷新持续时间2.程序设置信息管理已升级，支持保存中文注释信息，通过双击表格内条目更新3.添加内存数据查看的滚动条4.修复服务列表读取与写入 点击下载：配置工具-20190426 版本：20190419最低SDK版本：15改动：1.添加内存数据查看指令2.优化窗口退出点击下载：配置工具-20190419","categories":[],"tags":[]},{"title":"使用hexo 生成个人博客","slug":"使用hexo生成博客","date":"2019-04-25T05:46:34.434Z","updated":"2019-04-25T05:46:34.434Z","comments":true,"path":"2019/04/25/使用hexo生成博客/","link":"","permalink":"http://mijiku.com.cn/blog/2019/04/25/使用hexo生成博客/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Startif hexo version == 3.6npm install hexo-server Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"git使用指南","slug":"git使用指南","date":"2019-04-25T04:51:01.000Z","updated":"2019-04-29T03:02:35.866Z","comments":true,"path":"2019/04/25/git使用指南/","link":"","permalink":"http://mijiku.com.cn/blog/2019/04/25/git使用指南/","excerpt":"","text":"git 是一个开源的分布式版本控制系统，是Linus Torvalds 为了帮助管理Linux内核开发而开发的，适用于各种大大小小的项目版本管理 分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆，在本地机器上拷贝一个完整的Git仓库 首先来说一下基本使用流程1.从服务器上克隆完整的代码仓库git clone http://192.168.162.180:/git/charge 2.在自己的机器上根据不同的开发目的，创建分支，修改代码git branch charge //创建了一个与服务器同名的本地仓库，作为自己的工作仓库，也可以命名为其它的，一般情况下，分支的默认名为master 3.修改完代码后，将修改提交到本地仓库git commit -a -m “修改记录” //-m参数后面接的是之前修改过的内容描述 4.上传到服务器git push origin master //origin 代表远程服务器的别名，默认情况下是origin,master为默认分支名 以上4步为第一次使用的场景，后面介绍使用过程中的一些命令 1.查看远程服务器别名git remote -v 2.添加远程服务器git remote add xxx http://xxx.com/xxx 3.查看所有分支git branch -a //前面带星号的为当前分支 4.创建分支git branch xxx //以当前分支为起点，创建一个新的分支 5.重置分支git reset –hard //如果修改了很多东西，又觉得不满意，可以一键重置所有改动 6.合并远程服务器最新代码git pull origin master //如果本地的文件与服务器上的有差异，但差异点不一样，会自动合并成一个新的文件，如果差异点都在同一个地方，则需要手动合并，将冲突的地方修改好后，重新提交，上传到服务器 7.忽略文件权限git config core.filemode false //当前版本git config –global core.fileMode false //所有版本库7.忽略文件权限git config core.filemode false //当前版本git config –global core.fileMode false //所有版本库7.忽略文件权限git config core.filemode false //当前版本git config –global core.fileMode false //所有版本库7.忽略文件权限git config core.filemode false //当前版本git config –global core.fileMode false //所有版本库7.忽略文件权限git config core.filemode false //当前版本git config –global core.fileMode false //所有版本库7.忽略文件权限git config core.filemode false //当前版本git config –global core.fileMode false //所有版本库7.忽略文件权限git config core.filemode false //当前版本git config –global core.fileMode false //所有版本库","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://mijiku.com.cn/blog/tags/git/"}]},{"title":"apache+php搭建经历","slug":"apache-php搭建经历","date":"2017-03-29T15:39:38.000Z","updated":"2017-03-29T16:04:32.000Z","comments":true,"path":"2017/03/29/apache-php搭建经历/","link":"","permalink":"http://mijiku.com.cn/blog/2017/03/29/apache-php搭建经历/","excerpt":"","text":"最近公司使用的嵌入式网页服务器来做web开发，boa+cgi的，用起来太恶心了，所以。。。网上转了一圈，现在比较流行apache+php呀，那咱也造一个呗 先下载些材料 ，列表如下：apache 2.4.6一份,地址：http://archive.apache.org/dist/httpd/httpd-2.4.6.tar.gzapr 1.5.2一份，地址：https://mirrors.tuna.tsinghua.edu.cn/apache//apr/apr-1.5.2.tar.gzapr-util 1.5.4 一份，地址：https://mirrors.tuna.tsinghua.edu.cn/apache//apr/apr-util-1.5.4.tar.gzpcre-8.37一份，地址：https://ftp.pcre.org/pub/pcre/pcre-8.37.tar.gzphp-5.5.38一份，地址：http://cn.php.net/distributions/php-5.5.38.tar.gzlibxml2","categories":[],"tags":[]},{"title":"Linux C编程:打造一个插件系统","slug":"Linux-C编程-打造一个插件系统","date":"2017-03-07T13:16:36.000Z","updated":"2017-03-08T14:16:25.000Z","comments":true,"path":"2017/03/07/Linux-C编程-打造一个插件系统/","link":"","permalink":"http://mijiku.com.cn/blog/2017/03/07/Linux-C编程-打造一个插件系统/","excerpt":"","text":"运行环境：linux使用语言：c 或者c++ 插件，很多人用过，比如游戏插件，编辑器插件这些，最著名的就数魔兽大脚插件啦，还有vim插件啦，eclipse插件啦，等等插件有很多种形式，最常见的就是so文件，在windows上就是各种的dll啦 下面就让我们来了解一下插件式编程吧〜〜 举个例子，你开发了一个游戏，一开始只有三个关卡，分享给了你的小伙伴玩大家玩得很爽，但很快，游戏通关了，还想玩，这时候怎么办呢？常规做法就是再加两关，然后编译之后，再发给大家，那么问题就来了每次想加新关卡，都需要重新编译一次，再下载一次，这个流量嘛，1+1.1+1.2+1.3,每次加个0.1,都够你受的^_^这个时候嘛，就要引入插件系统了 咱先来写个小程序1234567891011121314151617181920212223242526272829303132333435//main.c#include &lt;stdio.h&gt;#include \"game.h\" //关于游戏的定义void initGame()&#123; &#125;void play()&#123; printf(\"我打，我打，我打打打\\n\");&#125;void loadMission()&#123;&#125;int main()&#123; initGame();//初始化游戏 int missionNum=loadMission();//读取关卡数 while(1) &#123; int missionNo=getchar();//选择关卡 missionNo=missionNo-'0'; if(missionNo&gt;missionNum) &#123; printf(\"没有此关卡!\\n\"); &#125; play(); &#125; &#125; 以上就是一个可扩展的游戏架构，够简单吧〜 下面咱就开始设计这个游戏系统的插件吧 在这里，游戏关卡就是我们的插件，一个插件就是一个关卡先讲讲一个插件的构造吧首先是这个关卡的描述，比如名称，难度等其次就是这个关卡游戏过程了最后，就是玩关卡的人 按照以上描述，咱定几个结构体吧12345678910111213141516171819202122232425262728293031323334353637//game.h#include &lt;stdio.h&gt;#include &lt;string.h&gt;//游戏玩家描述typedef struct _player&#123; int life;//玩家生命&#125;Player;//游戏关卡描述typedef struct _mission&#123; int level;//关卡难度 char missionName[30];//关卡名称 void (*process)(Player *);//游戏过程&#125;Mission;好了，下面就是一个插件的具体内容```c//game.c#include \"game.h\"const char name[]=\"第一关，插件入门\";const int level=1;void firstMission(Player *p)&#123; printf(\"oh my god ,somebody hurt me!\\n\"); p-&gt;life--; printf(\"now my life is %d\\n\",p-&gt;life); sleep(1);&#125;void gameInfo(Mission *m)&#123; m-&gt;level=level; int len=strlen(name); memcpy(m-&gt;missionName,name,len+1);//注意游戏名称不要太长 m-&gt;process=firstMission;&#125; Ok,以上就是一个关卡的所有东西了，虽然看着简单，不过还是建议动手敲敲^_^ 那我们先把这个插件制作出来吧，免得一会忘记了，在终端下执行以下命令：1gcc game.c -fPIC -shared -o firstMission.so -ldl linux和mac都一样 关卡设计好了，接下来就是怎么样读取我们做好的关卡了 现在实现咱们就loadMission()函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172Mission mission[50];int loadMission()&#123; FILE * fp; fp = fopen(\"missionList.txt\", \"r\");//读取关卡列表文件 if (NULL== fp) &#123; return 0; &#125; int ret=0; char namelist[50][50];//最多50个插件，每个插件的名字长度最多50 memset(namelist,0,sizeof(namelist)); int count=0; while(fgets((char *)&amp;namelist[count], 50, fp)) &#123; ret=strlen(namelist[count]);//计算实际字符串长度 if(namelist[count][ret-1]=='\\n') namelist[count][ret-1]='\\0';//fgets会读多一个换行，所以需要替换掉 count++; &#125; fclose(fp); ret=0;//用于累加错误次数 for(int i=0;i&lt;count;i++) &#123; const char *errmsg; dlerror(); // 清除错误 void *m_hLib = (void *)dlopen(namelist[i], RTLD_LAZY);//读取插件 if( (errmsg = dlerror()) != NULL ) &#123; //printf(\"err=%s\\n\",errmsg);打印错误 ret++;//累加错误次数 continue; &#125; if( m_hLib == NULL ) &#123; ret++;//累加错误次数 continue; &#125; dlerror(); // 清除错误 Info info = (Info)dlsym( m_hLib, \"gameInfo\" );//提取出插件里面的函数 if( (errmsg = dlerror()) != NULL ) &#123; dlclose(m_hLib); printf(\"err=%s\\n\",errmsg); ret++; continue; &#125; info(&amp;mission[i]);//获取到关卡数据 &#125; ret=0;//关卡号 //展示下关卡 for(int i=0;i&lt;count;i++) &#123; if(mission[i].level!=0) &#123; printf(\"%d.%s\\n\",ret+1,mission[i].missionName);/正式发布的时候就不要啦〜〜 ret++; &#125; &#125; count=count-ret;//计算有效关卡数 return count;&#125; 好了，上面的代码，不难吧？咱编译一下，就可以跑了linux下1gcc -o game main.c -Wl,rpath=. mac下1gcc -o game main.c -Wl,rpath . -dynamic 再准备一个游戏菜单文件，执行1echo firstMission.so &gt;missionlist.txt 好了，再执行1./game 一切顺利的话，你应该能看到自己的关卡列表了〜接下来干嘛呢？我们现在仅仅是提取出了关卡的名字，还没开始玩游戏呢以下是改动后的main.c文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;dlfcn.h&gt;#include &quot;game.h&quot; //关于游戏的定义Mission mission[50];void initGame()&#123; memset(mission,0,sizeof(mission));&#125;int loadMission()&#123; FILE * fp; fp = fopen(&quot;missionList.txt&quot;, &quot;r&quot;);//读取关卡列表文件 if (NULL== fp) &#123; return 0; &#125; int ret=0; char namelist[50][50];//最多50个插件，每个插件的名字长度最多50 memset(namelist,0,sizeof(namelist)); int count=0; while(fgets((char *)&amp;namelist[count], 50, fp)) &#123; ret=strlen(namelist[count]);//计算实际字符串长度 if(namelist[count][ret-1]==&apos;\\n&apos;) namelist[count][ret-1]=&apos;\\0&apos;;//fgets会读多一个换行，所以需要替换掉 count++; &#125; fclose(fp); ret=0; for(int i=0;i&lt;count;i++) &#123; const char *errmsg; dlerror(); // 清除错误 void *m_hLib = (void *)dlopen(namelist[i], RTLD_LAZY); if( (errmsg = dlerror()) != NULL ) &#123; //printf(&quot;err=%s\\n&quot;,errmsg);打印错误 ret++;//累加错误次数 continue; &#125; if( m_hLib == NULL ) &#123; ret++;//累加错误次数 continue; &#125; dlerror(); // 清除错误 Info info = (Info)dlsym( m_hLib, &quot;gameInfo&quot; ); if( (errmsg = dlerror()) != NULL ) &#123; dlclose(m_hLib); printf(&quot;err=%s\\n&quot;,errmsg); ret++; continue; &#125; info(&amp;mission[i]); &#125; //展示下关卡 for(int i=0;i&lt;count;i++) &#123; if(mission[i].level!=0) &#123; printf(&quot;%d.%s\\n&quot;,i+1,mission[i].missionName);//正式发布的时候就不要啦〜〜 &#125; &#125; count=count-ret;//计算有效关卡数 return count;&#125;int main()&#123; initGame();//初始化游戏 int missionNum=loadMission();//读取关卡数 if(missionNum==0) &#123; printf(&quot;游戏异常退出\\n&quot;); return -1; &#125; //初始化一个角色，并满血 Player p; while(1) &#123; p.life=100; printf(&quot;请选择关卡\\n&quot;); for(int i=0;i&lt;missionNum;i++) &#123; printf(&quot;%d.%s\\n&quot;,i+1,mission[i].missionName); &#125; int missionNo=getchar();//选择关卡 missionNo=missionNo-&apos;0&apos;; if(missionNo&gt;missionNum || missionNo&lt;1) &#123; printf(&quot;没有此关卡!\\n&quot;); continue; &#125; //读取来的关卡肯定是有难度等级的，没有就是无效关卡 if(mission[missionNo-1].level!=0) &#123; while(p.life&gt;0) mission[missionNo-1].process(&amp;p); &#125; printf(&quot;Game Over!\\n\\n\\n&quot;); &#125; &#125; 这就是一个完整的游戏啦，感兴趣的同学可以继续扩展哟〜〜后面就是不断得出扩展啦 你问我怎么扩展？好吧，自己把game.c里面的内容改改，然后编译出来，换个名字，然后在missionlist.txt里面加一行，就ok了 还不懂？那你只能给我打赏了^_^","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://mijiku.com.cn/blog/tags/linux/"}]},{"title":"关于Qt输出中文文件名乱码的问题","slug":"关于Qt输出中文文件名乱码的问题","date":"2017-03-07T04:21:26.000Z","updated":"2017-03-07T04:37:16.000Z","comments":true,"path":"2017/03/07/关于Qt输出中文文件名乱码的问题/","link":"","permalink":"http://mijiku.com.cn/blog/2017/03/07/关于Qt输出中文文件名乱码的问题/","excerpt":"","text":"最近为项目添加一个电能数据导出的功能导出的格式为csv,一开始文件名是1.csv,2.csv这样的，不过客户不满意呀〜〜那只能改成带有中文的呗 环境：嵌入式linux文件编码:utf-8 QFile f;QString head=QString(“time,current,voltage,activePower,reactivePower,energy\\n”);QString name=QString(“%1/直流支路%2数据.csv”).arg(“data”).arg(i+1);QString energyData=”12344”;f.setFileName(name);f.open(QIODevice::WriteOnly);f.write(head.toLocal8Bit());f.write(energyData.toUtf8());f.close(); 在嵌入式linux下，输出的文件名是乱码〜，因为在嵌入式linux下没有做中文处理不要紧，把文件输出到windows就行有一点要注意，这块代码的编码必须是utf-8的。。。平时我处理中文的时候，一般都会使用gbk编码来存代码，结果嘛，各种乱码输出。。。 这段代码唯一不足的就是head不能是中文，残念。。","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"61850","slug":"61850","permalink":"http://mijiku.com.cn/blog/tags/61850/"},{"name":"linux","slug":"linux","permalink":"http://mijiku.com.cn/blog/tags/linux/"},{"name":"git","slug":"git","permalink":"http://mijiku.com.cn/blog/tags/git/"}]}