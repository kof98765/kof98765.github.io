{"meta":{"title":"privatearea","subtitle":"会当凌绝顶，一览众山小","description":null,"author":"bingone","url":"http://mijiku.com.cn/blog","root":"/blog/"},"pages":[{"title":"About","date":"2019-04-24T02:09:54.000Z","updated":"2019-04-28T08:38:28.676Z","comments":true,"path":"about/index.html","permalink":"http://mijiku.com.cn/blog/about/index.html","excerpt":"","text":"QQ:277835572weixin:kof98765mail:277835572@qq.com"},{"title":"tags","date":"2019-04-24T02:09:40.000Z","updated":"2019-04-24T02:11:57.178Z","comments":true,"path":"tags/index.html","permalink":"http://mijiku.com.cn/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"sftp服务器搭建","slug":"sftp服务器搭建","date":"2020-12-30T11:40:02.824Z","updated":"2020-12-30T11:40:02.824Z","comments":true,"path":"2020/12/30/sftp服务器搭建/","link":"","permalink":"http://mijiku.com.cn/blog/2020/12/30/sftp服务器搭建/","excerpt":"","text":"sftp和ftp是两种不同的协议,sftp是ssh内含的协议，只要sshd服务器启动了，它就可用，它本身不需要ftp服务器启动。 1、查看软件版本,想sftp服务用户只能访问特定的文件目录,版本需要4.8以上 12[root@localhostftp]# ssh -V OpenSSH_8.1p1, LibreSSL 2.7.3 2、新增用户,限制用户只能通过sftp访问 1[root@localhostftp]# useradd -m -d /home/useradmin -s /sbin/nologin useradmin 3、限制用户通过sftp登录进来时只能进入主目录，修改/etc/ssh/sshd_config文件 12345678[root@localhostftp]# vim /etc/ssh/sshd_config #Subsystem sftp /usr/libexec/openssh/sftp-server Subsystem sftp internal-sftp Match User cxjbb ChrootDirectory /home/cxjbb X11Forwarding no AllowTcpForwarding no ForceCommand internal-sftp 4、重启sshd服务 1[root@localhostftp]#service sshd restart 5、测试访问 123456789root@10.1.1.200:test# sftp -oPort=22 useradmin@10.0.100.175 Connecting to 10.0.100.175... useradmin@10.0.100.175&apos;s password: Read from remote host 10.1.6.175: Connection reset by peer Couldn&apos;t read packet: Connection reset by peer 发现连接不上,查看日志 [root@localhostftp]# tail /var/log/messages Jan 6 11:41:41 localhost sshd[4907]: fatal: bad ownership or modes forchroot directory &quot;/opt/ftp/dave&quot; Jan 6 11:41:41 localhost sshd[4905]: pam_unix(sshd:session): session closed 6、解决方法: 目录权限设置上要遵循2点： ChrootDirectory设置的目录权限及其所有的上级文件夹权限，属主和属组必须是root； ChrootDirectory设置的目录权限及其所有的上级文件夹权限，只有属主能拥有写权限，权限最大设置只能是755。 如果不能遵循以上2点，即使是该目录仅属于某个用户，也可能会影响到所有的SFTP用户。 123456[root@localhostftp]# ll total 4 drwxr-xr-x 3 dave dave 4096 Jan 5 13:06 useradmin [root@localhostftp]# chown root:root useradmin [root@localhostftp]# chmod 755 useradmin [root@localhostftp]# ll total 4 drwxr-xr-x 3 root root 4096 Jan 5 13:06 useradmin 然后在测试通过 1234567891011root@10.1.1.200:test# sftp -oPort=22 useradmin@10.0.100.175 Connecting to 10.0.100.175... dave@10.0.100.175&apos;s password: sftp&gt;ls test sftp&gt;cd.. sftp&gt;ls test sftp&gt;cdtest sftp&gt;ls 1.txt sftp&gt; get 1.txt Fetching/test/1.txt to 1.txt /test/1.txt 可以看到已经限制用户在家目录,同时该用户也不能登录该机器。 7、linux下sftp关闭步骤 linux下ftp分为ftp和sftp，sftp属于带权限的传输方式,传输过程加密，从原理上看,sftp属于ssh的一部分。 如果不需要sftp需要关闭,执行如下方法: 编辑 /etc/ssh/sshd_config 文件 vim /etc/ssh/sshd_config 找到 PasswordAuthentication 项，将值由yes 修改为no 以root 权限重启SSH，命令： /etc/init.d/ssh restart","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://mijiku.com.cn/blog/tags/linux/"}]},{"title":"Linux下将根文件系统打包为镜像","slug":"linux下将根文件系统打包为镜像","date":"2020-12-30T06:50:25.324Z","updated":"2020-12-30T06:50:25.324Z","comments":true,"path":"2020/12/30/linux下将根文件系统打包为镜像/","link":"","permalink":"http://mijiku.com.cn/blog/2020/12/30/linux下将根文件系统打包为镜像/","excerpt":"","text":"创建镜像文件，指定镜像原始大小为1G1dd if=/dev/zero of=linux-rootfs.img bs=1M count=1024 /dev/zero：为虚拟盘的名字。linux-rootfs.img为你的穿建的镜像文件。bs=1Mcount=1024为此镜像的大小 设置镜像格式1mkfs.ext4 linux-rootfs.img 将镜像挂载为一个目录1mount linux-rootfs.img tmp 将文件复制到镜像目录12cp -rfp rootfs/ tmpumount tmp 调整镜像大小12e2fsck -p -f linux-rootfs.imgresize2fs -M linux-rootfs.img","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://mijiku.com.cn/blog/tags/linux/"}]},{"title":"嵌入式linux下进程内存占用分析","slug":"嵌入式linux下进程内存占用分析","date":"2019-11-27T08:31:27.000Z","updated":"2019-11-27T09:41:16.674Z","comments":true,"path":"2019/11/27/嵌入式linux下进程内存占用分析/","link":"","permalink":"http://mijiku.com.cn/blog/2019/11/27/嵌入式linux下进程内存占用分析/","excerpt":"","text":"在嵌入式linux下，可以通过cat /proc/进程号/smas查看该进程的内存使用情况在smaps文件中，每一条记录（如下所示）表示进程虚拟内存空间中一块连续的区域。其中第一行从左到右依次表示地址范围、权限标识、映射文件偏移、设备号、inode、文件路径。smaps文件部分内容格式：12345678910111213141516171819202122232425262728293031address perms offset dev inode pathname2e37a000-2e3b5000 r-xp 00000000 b3:01 4151 /opt/qt4.8.6/lib/libQtXml.so.4.8.6Size: 236 kBRss: 52 kBPss: 52 kBShared_Clean: 0 kBShared_Dirty: 0 kBPrivate_Clean: 52 kBPrivate_Dirty: 0 kBReferenced: 52 kBAnonymous: 0 kBAnonHugePages: 0 kBSwap: 0 kBKernelPageSize: 4 kBMMUPageSize: 4 kBLocked: 0 kB2e3b5000-2e3bc000 ---p 0003b000 b3:01 4151 /opt/qt4.8.6/lib/libQtXml.so.4.8.6Size: 28 kBRss: 0 kBPss: 0 kBShared_Clean: 0 kBShared_Dirty: 0 kBPrivate_Clean: 0 kBPrivate_Dirty: 0 kBReferenced: 0 kBAnonymous: 0 kBAnonHugePages: 0 kBSwap: 0 kBKernelPageSize: 4 kBMMUPageSize: 4 kBLocked: 0 kB 每一列的含义：address - This is the starting and ending address of the region in the process’s address spacepermissions - This describes how pages in the region can be accessed. There are four different permissions: read, write, execute, and shared. If read/write/execute are disabled, a - will appear instead of the r/w/x. If a region is not shared, it is private, so a p will appear instead of an s. If the process attempts to access memory in a way that is not permitted, a segmentation fault is generated. Permissions can be changed using the mprotect system call.offset - If the region was mapped from a file (using mmap), this is the offset in the file where the mapping begins. If the memory was not mapped from a file, it’s just 0.device - If the region was mapped from a file, this is the major and minor device number (in hex) where the file lives.inode - If the region was mapped from a file, this is the file number.pathname - If the region was mapped from a file, this is the name of the file. This field is blank for anonymous mapped regions. There are also special regions with names like [heap], [stack], or [vdso]. [vdso] stands for virtual dynamic shared object. It’s used by system calls to switch to kernel mode 接下来8个字段的含义分别如下： Size：表示该映射区域在虚拟内存空间中的大小。Rss：表示该映射区域当前在物理内存中占用了多少空间 Shared_Clean：和其他进程共享的未被改写的page的大小Shared_Dirty： 和其他进程共享的被改写的page的大小Private_Clean：未被改写的私有页面的大小。Private_Dirty： 已被改写的私有页面的大小。referenced:当前能够被引用到的内存,以及当前可达的内存.Anonymous:表示当前没有与文件联系在一块的内存,也就是说没有作为交换Swap：表示非mmap内存（也叫anonymous memory，比如malloc动态分配出来的内存）由于物理内存不足被swap到交换空间的大小。Pss：该虚拟内存区域平摊计算后使用的物理内存大小(有些内存会和其他进程共享，例如mmap进来的)。比如该区域所映射的物理内存部分同时也被另一个进程映射了，且该部分物理内存的大小为1000KB，那么该进程分摊其中一半的内存，即Pss=500KB。 以下是快速计算的命令，也可以通过cat /proc/进程号/status查看计算某进程的内存实际占用如进程号为12713,则1cat /proc/12713/smaps |grep ^Rss|awk &apos;&#123;s+=$2&#125;END&#123;print &quot;sum=&quot;s&#125;&apos; 计算某进程的虚拟内存占用1cat /proc/12713/smaps |grep ^Size|awk &apos;&#123;s+=$2&#125;END&#123;print &quot;sum=&quot;s&#125;&apos; awk将输出的数据进行统计","categories":[],"tags":[]},{"title":"使用mongoose搭建嵌入式网页服务器(二)","slug":"使用mongoose搭建嵌入式网页服务器-二","date":"2019-05-21T05:00:39.000Z","updated":"2019-05-21T05:00:39.075Z","comments":true,"path":"2019/05/21/使用mongoose搭建嵌入式网页服务器-二/","link":"","permalink":"http://mijiku.com.cn/blog/2019/05/21/使用mongoose搭建嵌入式网页服务器-二/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"使用mongoose搭建嵌入式网页服务器(一)","slug":"使用mongoose搭建嵌入式网页服务器","date":"2019-05-21T05:00:03.000Z","updated":"2019-05-21T07:27:29.459Z","comments":true,"path":"2019/05/21/使用mongoose搭建嵌入式网页服务器/","link":"","permalink":"http://mijiku.com.cn/blog/2019/05/21/使用mongoose搭建嵌入式网页服务器/","excerpt":"","text":"下载源码1git clone https://github.com/cesanta/mongoose 测试demo123cd mongoose/examples/simplest_web_servermake./simplest_web_server 以上，就是一个最简单的web服务器了不过只显示了当前目录下的文件，接下来我们就基于这个demo，制作自己的小网站 创建一个目录web，将mongoose/mongoose.c,mongoose/mongoose.h,mongoose/examples/simplest_web_server/simplest_web_server.c 复制到这个目录下 之后编写编译脚本，也可以写Makefile,随意〜〜以下是我的编译脚本build.sh1gcc mongoose.c simplest_web_server.c -o web build.sh权限，chmod 777 build.sh以后就可以执行./build.sh编译了 编写自己的网页修改simplest_web_server.c,代码如下：12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;mongoose.h&quot; static const char *s_http_port = &quot;8000&quot;;static struct mg_serve_http_opts s_http_server_opts; static void ev_handler(struct mg_connection *nc, int ev, void *p) &#123; if (ev == MG_EV_HTTP_REQUEST) &#123; struct http_message *msg=(struct http_message*)p; //限制浏览器的入口，只能访问/,或者/index,都会指向index.html这个文件 if(mg_vcmp(&amp;msg-&gt;uri,&quot;/index&quot;)==0 ||mg_vcmp(&amp;msg-&gt;uri,&quot;/&quot;)==0) &#123; mg_http_server_file(nc, msg,&quot;index.html&quot;,mg_mk_str(&quot;text/html&quot;),mg_mk_str(&quot;&quot;)); &#125; &#125;&#125; int main(void) &#123; struct mg_mgr mgr; struct mg_connection *nc; mg_mgr_init(&amp;mgr, NULL); printf(&quot;Starting web server on port %s\\n&quot;, s_http_port); nc = mg_bind(&amp;mgr, s_http_port, ev_handler);//绑定端口与事件处理器 if (nc == NULL) &#123; printf(&quot;Failed to create listener\\n&quot;); return 1; &#125; mg_set_protocol_http_websocket(nc); s_http_server_opts.document_root = &quot;.&quot;; // 设置网页的根目录 s_http_server_opts.enable_directory_listing = &quot;no&quot;;//关闭本地文件的显示 for (;;) &#123; mg_mgr_poll(&amp;mgr, 1000); &#125; mg_mgr_free(&amp;mgr); return 0;&#125; 另外编辑一个index.html文件1234567&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;H2&gt;Hello world!&lt;H2&gt;&lt;/body&gt;&lt;/html&gt; 执行./build.sh再执行./web打开浏览器，输入http://127.0.0.1:8000/即可看到网页内容 如果是放在板子上运行，只需将build.sh的编译命令改下，重新编译后，把执行文件和网页丢板上就好，比起boa来， 这个更容易懂些，也容易扩展些 以上是普通静态网页的做法，后面将会更新动态网页的写法，敬请期待〜〜","categories":[],"tags":[]},{"title":"嵌入式linux下使用mutt发送带附件的邮件","slug":"嵌入式linux下使用mutt发送带附件的邮件","date":"2019-05-21T00:37:56.000Z","updated":"2019-05-21T06:26:56.409Z","comments":true,"path":"2019/05/21/嵌入式linux下使用mutt发送带附件的邮件/","link":"","permalink":"http://mijiku.com.cn/blog/2019/05/21/嵌入式linux下使用mutt发送带附件的邮件/","excerpt":"","text":"之前已经使用msmtp成功发送了邮件，但如果要发送带附件的邮件，就需要配合mutt了 编译mutt编译mutt前，要先编译openssl和ncurses这两个库，编译方法就不在这说了在mutt官网上虽然有下载链接，但下不了，还好在github上找到了项目的源码，地址是https://github.com/muttmua/mutt可以使用git clone命令，或者直接下载zip包下载后进入到源码目录，执行12345./prepare #生成configure./configure --host=arm-linux --prefix=/opt/mutt --with-curses=/opt/ncurses -with-ssl CFLAGS=&quot;-I/opt/ncurses/include -I/opt/ncurses/include/ncurses -I/opt/openssl -L/opt/openssl/lib -lssl -lcrypto -L/opt/ncurses/lib&quot; LD=arm-linux-ld --disable-doc --disable-filemonitormake &amp;&amp;make install 将编译生成的mutt丢到板子上的/bin目录这里提供一个现成的点击下载：mutt.tar.gz执行mutt的时候有可能会出现vt100这类的错误,解决方法如下 12export TERM=vt100export TERMINFO=/usr/share/terminfo/v 如果系统中没有/usr/share/terminfo/v/vt100这个文件，就需要将pc上的文件复制过来了 使用mutt发邮件发送邮件前需要准备下配置文件 /etc/msmpt.conf123456789101112host smtp.163.com port 465auth logintls ontls_starttls offtls_certcheck off #关闭cert证书的检测，嵌入式下不关闭会有问题proxy_host 192.168.162.85 #这里使用了代理from xxxx@163.comuser xxxx@163.compassword xxxxxxtimeout 10logfile /var/log/msmtp.log /etc/mutt.conf123456set sendmail=&quot;/bin/msmtp -C /etc/msmtp.conf&quot;set use_from=yesset realname=&quot;xxxxx&quot;set editor=&quot;vi&quot;set from=xxxx@163.com #这里必须和msmtp的一样set envelope_from=yes 准备好配置文件后，就可以试试发送邮件了echo “hello world!”|mutt -s “hello,boy” 277835572@qq.com -a hello.jpg -F /etc/mutt.conf hello world!是邮件的内容，hello,boy是邮件的主题，后面接着接收人邮件地址，hello.jpg是附件，最后指定mutt的配置文件，这样就算大功告成啦 也可以预先把邮件内容写到某个文件中cat mail.txt |mutt -s “hello” 277835572@qq.com -a hello.jpg -F /etc/mutt.conf","categories":[],"tags":[]},{"title":"嵌入式linux下使用msmtp发送邮件","slug":"嵌入式linux下使用msmtp发送邮件","date":"2019-05-13T10:30:17.000Z","updated":"2019-05-21T06:19:44.297Z","comments":true,"path":"2019/05/13/嵌入式linux下使用msmtp发送邮件/","link":"","permalink":"http://mijiku.com.cn/blog/2019/05/13/嵌入式linux下使用msmtp发送邮件/","excerpt":"","text":"编译msmtparm gcc版本:4.8.3源码地址:https://marlam.de/msmtp/download/下载后解压，执行以下命令生成Makefile123./configure --host=arm-linux --prefix=/opt/msmtp libssl_CFLAGS=&quot;-I/share/env-dtu/include&quot; libssl_LIBS=&quot;-L/share/env-dtu/lib -lssl -lcrypto&quot; --with-tls=openssl make 虽然官方推荐使用gnutls作为tls的加密组件，但总是编译不过，只好使用opensslopenssl的编译方法这里就不提供了编译完成后，把src下的msmtp复制到开发板中的/bin下，编译这事就算完了这里提供一个现成的点击下载：msmtp.tar.gz 使用msmtp接下来是使用msmtp发送邮件首先准备好一个配置文件,命名为msmtp.conf，存放在/etc下，内容为：1234567891011host smtp.163.com #邮箱服务器地址port 465 #邮箱端口，一般465就是ssl加密端口auth login #启用登陆功能，现代服务器一般都需要验证的tls on #启用ssl加密码tls_starttls off #关闭starttls功能，一般只在非加密码环境下使用tls_certcheck off #关闭cert证书的检测from xxxx@163.com #发件人邮箱user xxxx@163.com #邮箱账号password xxxxxx #邮箱密码timeout 10 #发送超时logfile /var/log/msmtp.log #设置日志记录文件 接下来编写一封邮件，命名为mail,格式如下：123456Date:Mon May 13 18:16:30 UTC 2019Form:xxxx@163.comTo:taoyb@eastups.comSubject:testthis is a test! 第一行时间通过date命令得知，邮件内容之前要空一行之后执行1msmtp -C /etc/msmtp.conf -t &lt;mail -C 指定配置文件-t 用于接收mail的内容 以上就是使用msmtp发送163邮件的方法,接下来是一些常用操作 使用代理服务器发送邮件代理只能使用sock v5的1msmtp -C /etc/msmtp.conf --proxy-host=192.168.162.85 -t &lt;mail 发送不加密的邮件编缉配置文件，将port 改为25,tls改为off1msmtp -C /etc/msmtp.conf -t &lt;mail","categories":[],"tags":[]},{"title":"大量time wait的处理方法","slug":"大量time-wait的处理方法","date":"2019-04-30T07:02:08.000Z","updated":"2019-04-30T07:14:11.418Z","comments":true,"path":"2019/04/30/大量time-wait的处理方法/","link":"","permalink":"http://mijiku.com.cn/blog/2019/04/30/大量time-wait的处理方法/","excerpt":"","text":"有一天，自己的开发的服务软件连接不上了，ssh进到系统，netstat -an发现存在大量time wait信息在网上查询到如下描述：123在高并发短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。 解决方法如下:将以下内容写入/etc/sysctl.conf1234net.ipv4.tcp_syncookies = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_fin_timeout = 30 然后执行 /sbin/sysctl -p 让参数生效。 net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭； net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭； net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。 net.ipv4.tcp_fin_timeout 修改系統默认的 TIMEOUT 时间","categories":[],"tags":[]},{"title":"嵌入式syslog编译与使用","slug":"嵌入式syslog编译与使用","date":"2019-04-30T06:37:07.000Z","updated":"2019-04-30T06:59:12.006Z","comments":true,"path":"2019/04/30/嵌入式syslog编译与使用/","link":"","permalink":"http://mijiku.com.cn/blog/2019/04/30/嵌入式syslog编译与使用/","excerpt":"","text":"busybox下的syslogd不能同时监控多个log，所以需要自己编译一个 syslog该工具在inetutils工具包内首先下载安装包，然后解压，编译1234wget ftp://ftp.gnu.org/gnu/inetutils/inetutils-1.5.tar.gztar xvf inetutils-1.5.tar.gz &amp;&amp; cd inetutils-1.5CC=arm-none-linux-gnueabi-gcc LDFLAGS=-static ./configure --disable-clients --disable-ipv6 --disable-ncurses --host=arm --prefix=/opt/inetutilsmake 之后可在src/下找到syslogd，将之复制到开发板的/sbin目录内 但syslog不支持多线程打印，当两条线程同时使用时，需要自行加锁rsyslog是syslog的升级版，支持多线程编译步骤一样，但需要多安装一些库,这里就不多说了 syslog可以通过配置文件控制日志的输出，但不能指定日志的大小所以需要用到logrotate命令 logrotatelogrotate是linux中日志管理的重要工具，它可以自动对日志进行截断（或轮循）、压缩以及删除旧的日志文件。在发行版的桌面或者服务器linux系统中这个工具安装一般都是比较容易，或者默认已经自带，但是嵌入式系统一般需要通过源码来自己构建。 先安装编译依赖工具12apt-get install libtool-binapt-get install autopoint 构建POPT库由于logrotate依赖于POPT库，所以要生成logrotate需要先构建POPT库，然后再利用POPT库构建logrotate。下载最新的master分支源码包,并编译1git clone https://github.com/devzero2000/POPT 由于源码是基于autotools编译的，所以需要安装以下两个依赖工具12apt-get install libtool apt-get install autoconf 第一次编译需要先生成configure,执行以下命令1./autogen.sh 之后就可以使用configure这个程序来生成Makefile了，比如下面就是生成 arm版的命令123./configure --prefix=/opt/POPT --host=arm-linuxmakemake install 构建好后会在/opt/POPT 生成“include lib share” 三个目录，其中lib目录有logrotate编译和运行需要的库文件，include目录有我们编译logrotate需要的头文件。 构建logrotate下载最新的源码logrotate,并编译12345git clone https://github.com/logrotate/logrotate ./autogen.sh#./configure --host=arm-linux --prefix=/opt/logrotate LDFLAGS=-L/opt/POPT/lib CPPFLAGS=-I/opt/POPT/includemake make install 其中LDFLAGS指定logrotate编译依赖库lpopt路径；而CPPFLAGS指定logrotate编译依赖头文件popt.h路径。构建好后会在/opt/logrotate目录生成sbin/logrotate文件。 将/opt/POPT/lib/libpopt.so.0.0.0 复制到开发板的/lib下，并将名称改为libpopt.so.0将/opt/logrotate/sbin/logrotate 复制到开发板的/sbin目录 编写一个配置文件,存放到开发板的/etc目录下，名称为logrotate.cfg内容如下：1234567/var/log/testlog.log &#123; size=100k rotate 2 postrotate /usr/bin/killall -HUP syslogd endscript&#125; 脚本的功能为监控/var/log/testlog.log,当该文件大于100k时，备份，最多备份2次，每次备份时，会kill掉syslogd，不过syslogd是会自动重启的不用担心 之后还需要启动一个定时任务来周期性调用logrotate命令 首先在开发板上创建/etc/cron目录开机脚本写上12crond -c /etc/croncrontab -c /etc/cron /etc/cron/logrotate 开机脚本每个系统都不太一样，就不说了之后编写一个cron的配置文件放在/etc/cron目录下，文件名为logrotate内容为:1* * * * * logrotate /etc/logrotate.cfg 内容的意思是每分钟执行一次logrotate，这样就可以自动备份转存日志了","categories":[],"tags":[]},{"title":"使用git上传并自动部署服务端代码","slug":"使用git上传并自动部署服务端代码","date":"2019-04-29T00:15:31.000Z","updated":"2019-04-29T02:18:18.412Z","comments":true,"path":"2019/04/29/使用git上传并自动部署服务端代码/","link":"","permalink":"http://mijiku.com.cn/blog/2019/04/29/使用git上传并自动部署服务端代码/","excerpt":"","text":"一、git服务器搭建安装gitapt-get install git 创建git用户12adduser gitpasswd git //修改git用户密码 创建git仓库123456789$ cd /home$ mkdir git$ mkdir ./git/.ssh$ touch./git/.ssh/authorized_keys$ cd /home/git$ git init --bare test.git //初始化仓库$ chown -R git:git ../git$ chmod 700 .ssh // 需要设置成700，否则公钥认证会提示 (Permission denied)$ chmod 600 .ssh/authorized_key // 需要设置成600，否则公钥认证会提示 (Permission denied) 使用git用户生成git密钥把客户端的公钥（id_rsa.pb文件内容）添加到authorized_keys文件，git push操作就不需要每次都输入密码了） 123$ sudo -u git ssh-keygen -t rsa -C “test@qq.com” //生成密钥$ cd /home/git/.ssh$ cat id_rsa.pub&gt;&gt;authorized_keys //把公钥加入authorized_keys文件 创建web目录123$ cd /home$ git clone ssh://git@127.0.0.1/home/git/test.git //因为我的web服务器与git服务器是同一台主机所以使用127.0.0.1,如果不是放在同一台主机的请使用公网ip$ chown -R git:git test //test目录拥有设为git(如果test有其他的拥有者，可以把git加入其目录拥有者的组) 编写自动更新钩子12$ cd /home/git/test.git/hooks/$ vim post-receive 内容如下：12345#!/bin/shDIR=/home/testgit --work-tree=$&#123;DIR&#125; clean -fd# 直接强制检出 git --work-tree=$&#123;DIR&#125; checkout --force 给钩子文件添加执行权限12$ cd /home/git/test.git/hooks/$ chmod +x post-receive //给钩子文件添加执行权限 二、客户端测试验证生成客户端密钥12ssh-keygen -t rsa -C “test@qq.com” //生成密钥ssh-copy-id -i ~/.ssh/id_rsa.pub 服务器ip //将密钥上传到服务，以后就可以不用输密码了 然后把git仓库拷贝下来1git clone ssh://git@123.456.78.9/home/git/test.git 测试操作git push完成后git自动对web目录做git pull操作 123456cd testgit pull origin mastertouch test.txtgit add .git commit -m&apos;test&apos;git push origin master","categories":[],"tags":[]},{"title":"syslog使用方法","slug":"syslog使用方法","date":"2019-04-28T03:59:34.000Z","updated":"2019-04-28T06:51:19.019Z","comments":true,"path":"2019/04/28/syslog使用方法/","link":"","permalink":"http://mijiku.com.cn/blog/2019/04/28/syslog使用方法/","excerpt":"","text":"三个函数的原型和说明:123void openlog(char *ident,int option,int facility);void syslog(int priority,char *format, ...);void closelog(); log以时间，标题，内容组成log的生成路径可以通过修改配置文件来改变以下先看代码写法：12345678910111213141516#include &lt;syslog.h&gt;#include &lt;pthread.h&gt;//如果使用的是syslogd服务，则需要添加多线程锁，如果是使用rsyslog,则不需要pthread_mutex_t infoLock=PTHREAD_MUTEX_INITIALIZER;#define NoticeLog(format,args...) \\&#123; \\ pthread_mutex_lock(&amp;infoLock); \\ openlog(&quot;demo&quot;,0,LOG_LOCAL0); \\ syslog(LOG_INFO,format, ## args); \\ pthread_mutex_unlock(&amp;infoLock); \\&#125;int main()&#123; NoticeLog(&quot;a=%s&quot;,&quot;1111111111&quot;); &#125; 以上代码会生成的以下这样的logApr 28 11:00:41.850 demo: 1111111111 如果没有配置文件的话，log默认会输出到/var/log/message下 配置文件的格式为 facility.priority action，这些字段的定义如下： facility 指定产生消息的子系统。facility 有效的关键字有 auth、authpriv、cron、daemon、kern、lpr、mail、news、syslog、user、uucp 以及 local0 到 local7。 priority 指定消息的最低严重性，即此优先级和高于此优先级的消息将由这个规则匹配。priority 的有效关键字有 debug、info、notice、warning、err、crit、alert 和 emerg。 action action 字段可以是文件名、tty（如 /dev/console）、以 @ 为前缀的远程机器、以逗号分隔的用户列表，或是 * 以表明向所有登录用户发送消息。最常见的操作是一个简单的文件名。 以下是例子：1234567891011local0.info /root/app/data/info.loglocal0.info @192.168.162.245local0.notice /root/app/data/info1.loglocal1.* /root/app/data/notice.loglocal2.* /root/app/data/debug.loglocal3.* /root/app/data/warning.loglocal4.* /root/app/data/error.loglocal5.* /root/app/data/crit.loglocal6.* /root/app/data/alert.logkern.* /var/log/messageuser.* /var/log/message local0-7一般由用户自定义使用配置文件上配置有@ip的，则是将log发送到指定的机器上，默认是发到514的udp端口其它则是将log写到不同文件中 如下代码的意思是，将log输出到locall0.notice配置对应的文件里其中demo是此条log的名称，可以自定义12openlog(&quot;demo&quot;,0,LOG_LOCAL0); syslog(LOG_NOTICE,format, ## args); 系统一般会启动一个syslogd进程，不带配置文件的，所以我们需要修改启动项添加syslogd -f /etc/syslog.cfg -n &amp; 作为启动条件当更新了配置文件以后，也需要手动重新启动syslogd服务 log的文件大小是不作限制的，所以还需要配合logrotate 使用","categories":[],"tags":[]},{"title":"配置工具信息","slug":"配置工具信息","date":"2019-04-26T03:17:57.000Z","updated":"2020-11-24T10:31:25.498Z","comments":true,"path":"2019/04/26/配置工具信息/","link":"","permalink":"http://mijiku.com.cn/blog/2019/04/26/配置工具信息/","excerpt":"","text":"PS：每个版本都对应于SDK版本，不一定都兼容 版本：20201124最低SDK版本：16改动：1.添加mqtt搜索信息分组点击下载：配置工具-20201124 版本：20201009最低SDK版本：16改动：1.添加mqtt搜索方式点击下载：配置工具-20201009 版本：201901227最低SDK版本：16改动：1.自定义数据监控添加曲线功能2.加速配置读取点击下载：配置工具-20191227 版本：201900708最低SDK版本：16改动：1.添加自定义的数据监控配置2.修复读取设备配置表不刷新问题点击下载：配置工具-20190708 版本：20190428最低SDK版本：16改动：1.添加目标机器的syslog展示与过滤，需要本机作为log的服务器，所以使用的时候目标机器要能ping通本机点击下载：配置工具-20190428 版本：20190426最低SDK版本：16改动：1.实时数据页现在只传输当前选择的设备数据，持续一分钟可通过点击表格内的点来刷新持续时间2.程序设置信息管理已升级，支持保存中文注释信息，通过双击表格内条目更新3.添加内存数据查看的滚动条4.修复服务列表读取与写入 点击下载：配置工具-20190426 版本：20190419最低SDK版本：15改动：1.添加内存数据查看指令2.优化窗口退出点击下载：配置工具-20190419","categories":[],"tags":[]},{"title":"使用hexo 生成个人博客","slug":"使用hexo生成博客","date":"2019-04-25T05:46:34.434Z","updated":"2019-04-25T05:46:34.434Z","comments":true,"path":"2019/04/25/使用hexo生成博客/","link":"","permalink":"http://mijiku.com.cn/blog/2019/04/25/使用hexo生成博客/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Startif hexo version == 3.6npm install hexo-server Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"git使用指南","slug":"git使用指南","date":"2019-04-25T04:51:01.000Z","updated":"2019-04-29T03:02:35.866Z","comments":true,"path":"2019/04/25/git使用指南/","link":"","permalink":"http://mijiku.com.cn/blog/2019/04/25/git使用指南/","excerpt":"","text":"git 是一个开源的分布式版本控制系统，是Linus Torvalds 为了帮助管理Linux内核开发而开发的，适用于各种大大小小的项目版本管理 分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆，在本地机器上拷贝一个完整的Git仓库 首先来说一下基本使用流程1.从服务器上克隆完整的代码仓库git clone http://192.168.162.180:/git/charge 2.在自己的机器上根据不同的开发目的，创建分支，修改代码git branch charge //创建了一个与服务器同名的本地仓库，作为自己的工作仓库，也可以命名为其它的，一般情况下，分支的默认名为master 3.修改完代码后，将修改提交到本地仓库git commit -a -m “修改记录” //-m参数后面接的是之前修改过的内容描述 4.上传到服务器git push origin master //origin 代表远程服务器的别名，默认情况下是origin,master为默认分支名 以上4步为第一次使用的场景，后面介绍使用过程中的一些命令 1.查看远程服务器别名git remote -v 2.添加远程服务器git remote add xxx http://xxx.com/xxx 3.查看所有分支git branch -a //前面带星号的为当前分支 4.创建分支git branch xxx //以当前分支为起点，创建一个新的分支 5.重置分支git reset –hard //如果修改了很多东西，又觉得不满意，可以一键重置所有改动 6.合并远程服务器最新代码git pull origin master //如果本地的文件与服务器上的有差异，但差异点不一样，会自动合并成一个新的文件，如果差异点都在同一个地方，则需要手动合并，将冲突的地方修改好后，重新提交，上传到服务器 7.忽略文件权限git config core.filemode false //当前版本git config –global core.fileMode false //所有版本库7.忽略文件权限git config core.filemode false //当前版本git config –global core.fileMode false //所有版本库7.忽略文件权限git config core.filemode false //当前版本git config –global core.fileMode false //所有版本库7.忽略文件权限git config core.filemode false //当前版本git config –global core.fileMode false //所有版本库7.忽略文件权限git config core.filemode false //当前版本git config –global core.fileMode false //所有版本库7.忽略文件权限git config core.filemode false //当前版本git config –global core.fileMode false //所有版本库7.忽略文件权限git config core.filemode false //当前版本git config –global core.fileMode false //所有版本库","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://mijiku.com.cn/blog/tags/git/"}]},{"title":"apache+php搭建经历","slug":"apache-php搭建经历","date":"2017-03-29T15:39:38.000Z","updated":"2017-03-29T16:04:32.000Z","comments":true,"path":"2017/03/29/apache-php搭建经历/","link":"","permalink":"http://mijiku.com.cn/blog/2017/03/29/apache-php搭建经历/","excerpt":"","text":"最近公司使用的嵌入式网页服务器来做web开发，boa+cgi的，用起来太恶心了，所以。。。网上转了一圈，现在比较流行apache+php呀，那咱也造一个呗 先下载些材料 ，列表如下：apache 2.4.6一份,地址：http://archive.apache.org/dist/httpd/httpd-2.4.6.tar.gzapr 1.5.2一份，地址：https://mirrors.tuna.tsinghua.edu.cn/apache//apr/apr-1.5.2.tar.gzapr-util 1.5.4 一份，地址：https://mirrors.tuna.tsinghua.edu.cn/apache//apr/apr-util-1.5.4.tar.gzpcre-8.37一份，地址：https://ftp.pcre.org/pub/pcre/pcre-8.37.tar.gzphp-5.5.38一份，地址：http://cn.php.net/distributions/php-5.5.38.tar.gzlibxml2","categories":[],"tags":[]},{"title":"Linux C编程:打造一个插件系统","slug":"Linux-C编程-打造一个插件系统","date":"2017-03-07T13:16:36.000Z","updated":"2017-03-08T14:16:25.000Z","comments":true,"path":"2017/03/07/Linux-C编程-打造一个插件系统/","link":"","permalink":"http://mijiku.com.cn/blog/2017/03/07/Linux-C编程-打造一个插件系统/","excerpt":"","text":"运行环境：linux使用语言：c 或者c++ 插件，很多人用过，比如游戏插件，编辑器插件这些，最著名的就数魔兽大脚插件啦，还有vim插件啦，eclipse插件啦，等等插件有很多种形式，最常见的就是so文件，在windows上就是各种的dll啦 下面就让我们来了解一下插件式编程吧〜〜 举个例子，你开发了一个游戏，一开始只有三个关卡，分享给了你的小伙伴玩大家玩得很爽，但很快，游戏通关了，还想玩，这时候怎么办呢？常规做法就是再加两关，然后编译之后，再发给大家，那么问题就来了每次想加新关卡，都需要重新编译一次，再下载一次，这个流量嘛，1+1.1+1.2+1.3,每次加个0.1,都够你受的^_^这个时候嘛，就要引入插件系统了 咱先来写个小程序1234567891011121314151617181920212223242526272829303132333435//main.c#include &lt;stdio.h&gt;#include \"game.h\" //关于游戏的定义void initGame()&#123; &#125;void play()&#123; printf(\"我打，我打，我打打打\\n\");&#125;void loadMission()&#123;&#125;int main()&#123; initGame();//初始化游戏 int missionNum=loadMission();//读取关卡数 while(1) &#123; int missionNo=getchar();//选择关卡 missionNo=missionNo-'0'; if(missionNo&gt;missionNum) &#123; printf(\"没有此关卡!\\n\"); &#125; play(); &#125; &#125; 以上就是一个可扩展的游戏架构，够简单吧〜 下面咱就开始设计这个游戏系统的插件吧 在这里，游戏关卡就是我们的插件，一个插件就是一个关卡先讲讲一个插件的构造吧首先是这个关卡的描述，比如名称，难度等其次就是这个关卡游戏过程了最后，就是玩关卡的人 按照以上描述，咱定几个结构体吧12345678910111213141516171819202122232425262728293031323334353637//game.h#include &lt;stdio.h&gt;#include &lt;string.h&gt;//游戏玩家描述typedef struct _player&#123; int life;//玩家生命&#125;Player;//游戏关卡描述typedef struct _mission&#123; int level;//关卡难度 char missionName[30];//关卡名称 void (*process)(Player *);//游戏过程&#125;Mission;好了，下面就是一个插件的具体内容```c//game.c#include \"game.h\"const char name[]=\"第一关，插件入门\";const int level=1;void firstMission(Player *p)&#123; printf(\"oh my god ,somebody hurt me!\\n\"); p-&gt;life--; printf(\"now my life is %d\\n\",p-&gt;life); sleep(1);&#125;void gameInfo(Mission *m)&#123; m-&gt;level=level; int len=strlen(name); memcpy(m-&gt;missionName,name,len+1);//注意游戏名称不要太长 m-&gt;process=firstMission;&#125; Ok,以上就是一个关卡的所有东西了，虽然看着简单，不过还是建议动手敲敲^_^ 那我们先把这个插件制作出来吧，免得一会忘记了，在终端下执行以下命令：1gcc game.c -fPIC -shared -o firstMission.so -ldl linux和mac都一样 关卡设计好了，接下来就是怎么样读取我们做好的关卡了 现在实现咱们就loadMission()函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172Mission mission[50];int loadMission()&#123; FILE * fp; fp = fopen(\"missionList.txt\", \"r\");//读取关卡列表文件 if (NULL== fp) &#123; return 0; &#125; int ret=0; char namelist[50][50];//最多50个插件，每个插件的名字长度最多50 memset(namelist,0,sizeof(namelist)); int count=0; while(fgets((char *)&amp;namelist[count], 50, fp)) &#123; ret=strlen(namelist[count]);//计算实际字符串长度 if(namelist[count][ret-1]=='\\n') namelist[count][ret-1]='\\0';//fgets会读多一个换行，所以需要替换掉 count++; &#125; fclose(fp); ret=0;//用于累加错误次数 for(int i=0;i&lt;count;i++) &#123; const char *errmsg; dlerror(); // 清除错误 void *m_hLib = (void *)dlopen(namelist[i], RTLD_LAZY);//读取插件 if( (errmsg = dlerror()) != NULL ) &#123; //printf(\"err=%s\\n\",errmsg);打印错误 ret++;//累加错误次数 continue; &#125; if( m_hLib == NULL ) &#123; ret++;//累加错误次数 continue; &#125; dlerror(); // 清除错误 Info info = (Info)dlsym( m_hLib, \"gameInfo\" );//提取出插件里面的函数 if( (errmsg = dlerror()) != NULL ) &#123; dlclose(m_hLib); printf(\"err=%s\\n\",errmsg); ret++; continue; &#125; info(&amp;mission[i]);//获取到关卡数据 &#125; ret=0;//关卡号 //展示下关卡 for(int i=0;i&lt;count;i++) &#123; if(mission[i].level!=0) &#123; printf(\"%d.%s\\n\",ret+1,mission[i].missionName);/正式发布的时候就不要啦〜〜 ret++; &#125; &#125; count=count-ret;//计算有效关卡数 return count;&#125; 好了，上面的代码，不难吧？咱编译一下，就可以跑了linux下1gcc -o game main.c -Wl,rpath=. mac下1gcc -o game main.c -Wl,rpath . -dynamic 再准备一个游戏菜单文件，执行1echo firstMission.so &gt;missionlist.txt 好了，再执行1./game 一切顺利的话，你应该能看到自己的关卡列表了〜接下来干嘛呢？我们现在仅仅是提取出了关卡的名字，还没开始玩游戏呢以下是改动后的main.c文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;dlfcn.h&gt;#include &quot;game.h&quot; //关于游戏的定义Mission mission[50];void initGame()&#123; memset(mission,0,sizeof(mission));&#125;int loadMission()&#123; FILE * fp; fp = fopen(&quot;missionList.txt&quot;, &quot;r&quot;);//读取关卡列表文件 if (NULL== fp) &#123; return 0; &#125; int ret=0; char namelist[50][50];//最多50个插件，每个插件的名字长度最多50 memset(namelist,0,sizeof(namelist)); int count=0; while(fgets((char *)&amp;namelist[count], 50, fp)) &#123; ret=strlen(namelist[count]);//计算实际字符串长度 if(namelist[count][ret-1]==&apos;\\n&apos;) namelist[count][ret-1]=&apos;\\0&apos;;//fgets会读多一个换行，所以需要替换掉 count++; &#125; fclose(fp); ret=0; for(int i=0;i&lt;count;i++) &#123; const char *errmsg; dlerror(); // 清除错误 void *m_hLib = (void *)dlopen(namelist[i], RTLD_LAZY); if( (errmsg = dlerror()) != NULL ) &#123; //printf(&quot;err=%s\\n&quot;,errmsg);打印错误 ret++;//累加错误次数 continue; &#125; if( m_hLib == NULL ) &#123; ret++;//累加错误次数 continue; &#125; dlerror(); // 清除错误 Info info = (Info)dlsym( m_hLib, &quot;gameInfo&quot; ); if( (errmsg = dlerror()) != NULL ) &#123; dlclose(m_hLib); printf(&quot;err=%s\\n&quot;,errmsg); ret++; continue; &#125; info(&amp;mission[i]); &#125; //展示下关卡 for(int i=0;i&lt;count;i++) &#123; if(mission[i].level!=0) &#123; printf(&quot;%d.%s\\n&quot;,i+1,mission[i].missionName);//正式发布的时候就不要啦〜〜 &#125; &#125; count=count-ret;//计算有效关卡数 return count;&#125;int main()&#123; initGame();//初始化游戏 int missionNum=loadMission();//读取关卡数 if(missionNum==0) &#123; printf(&quot;游戏异常退出\\n&quot;); return -1; &#125; //初始化一个角色，并满血 Player p; while(1) &#123; p.life=100; printf(&quot;请选择关卡\\n&quot;); for(int i=0;i&lt;missionNum;i++) &#123; printf(&quot;%d.%s\\n&quot;,i+1,mission[i].missionName); &#125; int missionNo=getchar();//选择关卡 missionNo=missionNo-&apos;0&apos;; if(missionNo&gt;missionNum || missionNo&lt;1) &#123; printf(&quot;没有此关卡!\\n&quot;); continue; &#125; //读取来的关卡肯定是有难度等级的，没有就是无效关卡 if(mission[missionNo-1].level!=0) &#123; while(p.life&gt;0) mission[missionNo-1].process(&amp;p); &#125; printf(&quot;Game Over!\\n\\n\\n&quot;); &#125; &#125; 这就是一个完整的游戏啦，感兴趣的同学可以继续扩展哟〜〜后面就是不断得出扩展啦 你问我怎么扩展？好吧，自己把game.c里面的内容改改，然后编译出来，换个名字，然后在missionlist.txt里面加一行，就ok了 还不懂？那你只能给我打赏了^_^","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://mijiku.com.cn/blog/tags/linux/"}]},{"title":"关于Qt输出中文文件名乱码的问题","slug":"关于Qt输出中文文件名乱码的问题","date":"2017-03-07T04:21:26.000Z","updated":"2017-03-07T04:37:16.000Z","comments":true,"path":"2017/03/07/关于Qt输出中文文件名乱码的问题/","link":"","permalink":"http://mijiku.com.cn/blog/2017/03/07/关于Qt输出中文文件名乱码的问题/","excerpt":"","text":"最近为项目添加一个电能数据导出的功能导出的格式为csv,一开始文件名是1.csv,2.csv这样的，不过客户不满意呀〜〜那只能改成带有中文的呗 环境：嵌入式linux文件编码:utf-8 QFile f;QString head=QString(“time,current,voltage,activePower,reactivePower,energy\\n”);QString name=QString(“%1/直流支路%2数据.csv”).arg(“data”).arg(i+1);QString energyData=”12344”;f.setFileName(name);f.open(QIODevice::WriteOnly);f.write(head.toLocal8Bit());f.write(energyData.toUtf8());f.close(); 在嵌入式linux下，输出的文件名是乱码〜，因为在嵌入式linux下没有做中文处理不要紧，把文件输出到windows就行有一点要注意，这块代码的编码必须是utf-8的。。。平时我处理中文的时候，一般都会使用gbk编码来存代码，结果嘛，各种乱码输出。。。 这段代码唯一不足的就是head不能是中文，残念。。","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://mijiku.com.cn/blog/tags/linux/"},{"name":"git","slug":"git","permalink":"http://mijiku.com.cn/blog/tags/git/"}]}